(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports, require("three"))
    : typeof define === "function" && define.amd
    ? define(["exports", "three"], factory)
    : ((global = global || self), factory((global.PANOLENS = {})));
})(this, function (exports) {
  "use strict";

  const version = "0.10.0";

  /**
   * REVISION
   * @module REVISION
   * @example PANOLENS.REVISION
   * @type {string} version
   */
  const REVISION = version;

  /**
   * CONTROLS
   * @module CONTROLS
   * @example PANOLENS.CONTROLS.ORBIT
   * @property {number} ORBIT 0
   * @property {number} DEVICEORIENTATION 1
   */
  const CONTROLS = { ORBIT: 0, DEVICEORIENTATION: 1 };

  /**
   * MODES
   * @module MODES
   * @example PANOLENS.MODES.UNKNOWN
   * @property {number} UNKNOWN 0
   * @property {number} NORMAL 1
   * @property {number} CARDBOARD 2
   * @property {number} STEREO 3
   */
  const MODES = { UNKNOWN: 0, NORMAL: 1, CARDBOARD: 2, STEREO: 3 };

  /**
   * Data URI Images
   * @module DataImage
   * @example PANOLENS.DataImage.Info
   * @property {string} Info Information Icon
   * @property {string} Arrow Arrow Icon
   * @property {string} FullscreenEnter Fullscreen Enter Icon
   * @property {string} FullscreenLeave Fullscreen Leave Icon
   * @property {string} VideoPlay Video Play Icon
   * @property {string} VideoPause Video Pause Icon
   * @property {string} WhiteTile White Tile Icon
   * @property {string} Setting Settings Icon
   * @property {string} ChevronRight Chevron Right Icon
   * @property {string} Check Check Icon
   * @property {string} ViewIndicator View Indicator Icon
   */
  const DataImage = {
    Info: "data:image/png;base64,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",
	Arrow:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAB2AAAAdgB+lymcgAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA1hSURBVHiczZt7dFTVvcc/+5wz78lMEkKEBELklUDUglWKEMBiudxrL+VSbSugoKiBWl/0tj6W93Z571qudWsrtXV1VewVEJFg1Hv11tbSWhGpiAIFgYTMBEgK4R2SzCOTSWbm7PvHkMlMnmfyQL9rzZpz9t6//Xuc32+f334cwTBj8zFnrimqzkXIEqlTLASTgSwgE3BebhYEmoEmBB4B1bouKqOm2K4VE4MXhlM+MRydbvO4bpQ6SxFiAciSQfCRICqllH8SQpQvLfbtG0o5YQgNsKUm26VGI2UIsQqYMlT9JkNKqgRyo11Y1i8ubggMRZ+DNkBFpSs7qvCIEDxE3LWvBJqQ/EqPiF8uv87XNJiOBmwAKRGve113ScnPgZGDEWIQaBTwn9VF/heeFugD6WBABqiodE2MqbwCzBoI/TDgY6GKlXdM8h1Pl1BJl6Dck7FEV9nLl0d5gNl6TB7Y5nHdkS6hYQ94WqIUe1zPSXg0XSYdUIQZl3kSGeZJWLVcNOHAqcwgpodo1etpbt/HxfBfiOqhgbJAStZ5i/0/NhoShgxQUYk5prk2IVmarkAWNZuCjNvId36TkbaZqIotpf5CY6qyQoAufDRHd+HxP0MoUpcuS4Ct/qD/7tU3EOmvYb8GqKjErKuu/5VwazoSOM3jmZq9lkLXHSjC3Gu7rgboKly7OEGV/wkuhXelwx4kv/e3+Jf0Z4Q+DSAlorzatUkIVhjlqyl2SkY8TlHWD1CEqd/2fRkgWcgQB9l3aTkRvdGoKCAo90z239lXOPQ5CL7uca1LR3mXuZgFBR8wJftRQ8obhQRsTGPuyM8ZbV+UDuHSIo/7p3016dUDtlW7vyORFUZ55TtvZVbeBlRh679xEox4QDKEgFPhX+D1P2uYRkqWLZviL++xv54Kt9W4J8iY3A+4jTAoyLiNm0a/hBCaYaE6kK4BOnAusoGq5qeMNvfpirh++WTfia4V3UJASoSMyc0YVH6U4xZmjl4/IOUHg9GmVRRaHzba3K3ocpOU3R94NwOUezPuxWCSYzeNYdbol4c03o1CAhNcT+KUXzNKMqe8OqPbeJZikYpKV3ZMxQPk9NebQOGWgu3k2GYYFaBHDDQEOiAJ8l7dZKwOaYhd2KIU3XN1c3NHQYoHxFQexYDyABMyVw5a+aGAwMm1WesItxgyQK6tXU+Jm4QHbKnJdqmxaB0GprSqYmPR+MNY1cFPAgfrAQBCSN44WITd7cfq6De3a7RjLuxYT0h4gBqNlGFwPj/BvWJIlB8qSCmYPeE5fI3SiCdkt4q2+ztuOkNAKCuNMhzvNtz0iiEv4x9BYsgIui7u7bhWIL6GB/IaI4yyLNeRaSkZlLDDASlNFI74Z0NGEIKp5TWZ0wE0gPgCpjFGoxy39CKAxFtTS82xOgItLbhdGRQW5DOleCJC9Nz5yVNneHlzBQ2XGjBpGoWFhSxcuIARWVkp/X6w48PE/bw5pZw6fZoTJ2oByM/Lo7i4CIBJucupu/RuwghA72NCTC4DDsSzF4V/wNAgCrn22d3K6v5ez4bNb3Lm7PludQVj8/j+/csZmZOdKPP5Amx49U2OVHqp/bs3UX7oyGHefe/3zCudx+r7VwEghGDj5leIRmMJA1RWVrGlPJ7Z/tPChQkDZNqmdTLuxwgC+Q0AZfMxZy6SqcbUB3cX96+tO8XPfvHbHpWH+FN+dt16gsEWAILBFv5r3Xoqq7w9ttdjOjt27mDdL3+VKLNYrQComoZmMmG3d843bLbOa5PSJXntIxwkfGWrJyNHM0XVuSANBYAqbNi10Z2dSMmmLW/R1t4OQOG4MSz9ziLGFeRz/kIDW8rf5njtSYqLJhC5/AT/553tXLx4CYARI9zMKb2Lr99cyrlzF3j1tXKqqqsA2LtvH5VVRymZOgWH3U5LsAWbzdpNaZvVliSPiknLIBJNWjHv3ROEosu5GlJeYzT+zaqb5OTx+ImTnD4Tf/Iul5O1D96Dw2EHID/vKh56YCXNzX7yRucC0B6JsGfvQQAUReHB1SuwOjIBuPrqQn7yb0/yoyeepL6+Hiklb//ud5RMnZJQ2H75P8UANkuKjE7zGJqiR1MFl+C7JBFCYLEnFQulRJNQZHRhsOtU9+SpM4nr6V8pSSj/zrvv4/On7ltMmlBIXt5VtLfHF2jyRudSMDavWyJ085y5bCnfCsCZ02dTFLZae/AAmz2F3mrqPZFtbtDJzFESRpBQpCmCSQbHP6KyJeW+PdK52uRIisu9fzvEuXMXU4mlTBkIk9snIyu78w0Qjcb7tyc8IC55aghYU+gjsb43jJKNIGCyIg3m/gDtsdRNmOyszkHnRN2pFKHsdhsWi7nX9qfPnE8xYAcOHT6cuHa5XABkujNxOhxkZsbDxeFw4Lz8sztSPSDUfrZfPZobdNrijpejARn9UlyGLiO06z7Ml0fbqcUT0TSNaDRKtec4H3+yn9k3fZWnHnsAgP0HjvCb376WoM/OzmRM/ijqT58j2BLirbf/yPz58xN5grfmGLt37060/+q06QCU3XcvK+5cngiBEdnZvPjrX4PU0UydU3EhINTe89uoJyNk5igjNDq3qI0Rhg+Ra58DgNPpYMEtpby3/UMANr76Jp98doBxY/NobPLx+aHOwUgo8az724sX8sJvNiOl5P0PdlP+xlsUjC0gGAxQf7oeXY+vXzrsTm6/fQkAL770Eh9+tIuv3Xgjax95mPr60/zHM88QiUR47F9/yNQp8b1YvUuI9gffJd2V9s5QQ+tnKfdLFi1g5ozpiftqz3G2v7+LvfsPJVy8YGwei26dD8B11xTz3du+iXLZIMFggKqjlZw8dTKhvM1m46knHkPTNHRd56O/fgzAp3v3Egq1sv/AAQKBAOFwmN179iR4B9p6zi16gwTU2x+0rAUMr2QKoVKYtAMlhOD6aSWMHZNHS0uIZp8fXddRVZVxBfncuvBm7lr2L4mBDGDC1QVcW1JEKBTCc+wYMqG4neunT+Opxx9n1KirEv37fQFO1NYyb04ps26aidudwd69+1A0lWXf+x45I0YAcKzhZc4HUh9QX1AUdFFe7aoDxhk3gMa3xh/BlpQQdUVraxir1dLrHCAZFxpDBINBTCZzt0EzGdFoDE1TE/dSSqSUCU8SQlLxt0KietioKigqUUVAg2EKQMoodf5tfbax2ayGlO+A0+nsU3kgRXmIe0aH8gD+tiNpKQ8gFNGmSEF6gQPUNP83MZkes+GEAPbU/ihtOlXlggJ40iUMRerxNr2YNsPhQqD9CA3Bg2nTKUKcUKQujgyEadWl54jq6b12hgNC6HzgvXNAtIom9ylRU2wXGF0N6ERE9xPRfQNiPJQ4cu6ntLT1n/11gwBsbFDi5/BE5ZBLdgXQ1PoJh+qfHxCtqtJaNi3gjQ+jUv55KAW7EghHa/lj1bcHTK9ZxGHoWBUWYuvQiHVl0BL18M7hUhjYwTAAhCLXwWUDxE9gDmwwvJIQwLnAH/i/z+ei69EB96NqtK25Kfg6JO8LSP2VQUs4rGjjs5MPscN7z6B70ixs77hOGMAuLOuBQZ26HA4IEeNM4G1ePzCRYxcNn9foFYqCdMasaxL3HReLixsCUvLCoDl0QUxvo75pF5GY8T1AAURlIyeaNvLGwcns9K5G19uHRB6zVey4a25D4r2ZcqpBRsTzwiy/zxAdfT3VuJMd1WtpaqlBVcyMct9AflYpWfaJ2C2jsGiZCFGALiNEdB/BcB3nA7vxnt9MayStKYohKAp6zGy6O7ms24ylvDpjFYiXjXS4eMJRbFpet/JQ+wX+6v13jp4tZwA51rDB7mR92azgmuSybgaQErHN49oFdN8C6oLuBpBUn93GTs8ThCNpHGe7AjCZhe+BeYFs0eXIXLcVISGQQhUrgbTy3IbAYSo++wbbj5R96ZRXFKTJri7uqjz0ck4wfupa3Gek82gsxMc1P6H807mc9RlfjbmSsNjFz8tmNO/sqa7PVYutR13PCcEPe6u/1v0se7zrCLad6a3JFw6rXXy6pjQws7f6fo/KbvO6NiC5u6f6cKvEd/HLM8h1hdki6i7ogUlPf51e08Y+V4WFQPoD/jIBf+ip3moTZI4clu+uBg2ThfOqI1DSl/Jg4IOJ1TcQueqsfzGIDT3VW2wC95fMCGarqNUcwfGrb6Df7Muw5PHXo/tZkD0uvoVDEl/DFx8OVrv4dPXswKyeRvyeYHhjRAjk0mLfj6WQS+hhzmC1f7GeoChIm5Pn15QGZhpVHgb40dRrXvd4RZebgDld674ITzCZhc9iUr913+zmj9KlHYrP5n4G5CbXtbVKmq/A20FRkBab8lrZLP/KdJ56MgbtsxtrMzNt7frDUvIIkDgAMJyeoChIs1XsiJlNd/9gRuOp/il6x5AFbUXlSKeuhcskYhWSEhh6I2gmwpqJ7S63ffWyay8Y2wfvB8MyapXXZE6Pn8PTF4RDXOdvkGJAZhCgabSqZnFYKHJdxzLWUGLYh+2tnoyclka5OhoT82WM8brOSCmlWepoHR8wCIEUClEhRLuiclER4riiyX3Y2FA2LZD21l06+H8ClQlH0n30lwAAAABJRU5ErkJggg==",
    FullscreenEnter:
      "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
    FullscreenLeave:
      "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
    VideoPlay:
      "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
    VideoPause:
      "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
    WhiteTile:
      "data:image/png;base64,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",
    Setting:
	  "data:image/png;base64,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",
     // "data:image/png;base64,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",
    //Setting: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC',
    ChevronRight:
      "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
    Check:
	  "data:image/png;base64,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",
      //"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
    ViewIndicator:
	  "data:image/png;base64,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",
      //"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+",

    /*
			Author: silqwer
			compass images
		*/

    CompassBackground: "",
    CompassInnerDot: "",
    //CompassInnerView: 'data:image/png;base64,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',
    CompassInnerView:
	"data:image/png;base64,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",
	//"data:image/png;base64,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",
    //CompassInnerView: 'data:image/png;base64,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',
    CompassOuterRing: "",
  };

  /**
   * @module ImageLoader
   * @description Image loader with progress based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/ImageLoader.js}
   */
  const ImageLoader = {
    /**
     * Load image
     * @example PANOLENS.ImageLoader.load( IMAGE_URL )
     * @method load
     * @param  {string}   url        - An image url
     * @param  {function} onLoad     - On load callback
     * @param  {function} onProgress - In progress callback
     * @param  {function} onError    - On error callback
     */
    load: function (url, onLoad, onProgress, onError) {
      // Enable cache
      THREE.Cache.enabled = true;

      let cached, request, arrayBufferView, blob, urlCreator, image, reference;

      // Reference key
      for (let iconName in DataImage) {
        if (DataImage.hasOwnProperty(iconName) && url === DataImage[iconName]) {
          reference = iconName;
        }
      }

      // Cached
      cached = THREE.Cache.get(reference ? reference : url);

      if (cached !== undefined) {
        if (onLoad) {
          setTimeout(function () {
            if (onProgress) {
              onProgress({ loaded: 1, total: 1 });
            }

            onLoad(cached);
          }, 0);
        }

        return cached;
      }

      // Construct a new XMLHttpRequest
      urlCreator = window.URL || window.webkitURL;
      image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

      // Add to cache
      THREE.Cache.add(reference ? reference : url, image);

      const onImageLoaded = () => {
        urlCreator.revokeObjectURL(image.src);
        onLoad && onLoad(image);
      };

      if (url.indexOf("data:") === 0) {
        image.addEventListener("load", onImageLoaded, false);
        image.src = url;
        return image;
      }

      image.crossOrigin =
        this.crossOrigin !== undefined ? this.crossOrigin : "";

      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      request.onprogress = function (event) {
        if (event.lengthComputable) {
          onProgress &&
            onProgress({ loaded: event.loaded, total: event.total });
        }
      };
      request.onloadend = function (event) {
        arrayBufferView = new Uint8Array(this.response);
        blob = new Blob([arrayBufferView]);

        image.addEventListener("load", onImageLoaded, false);
        image.src = urlCreator.createObjectURL(blob);
      };

      request.send(null);
    },
  };

  /**
   * @module TextureLoader
   * @description Texture loader based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/TextureLoader.js}
   */
  const TextureLoader = {
    /**
     * Load image texture
     * @example PANOLENS.TextureLoader.load( IMAGE_URL )
     * @method load
     * @param  {string}   url        - An image url
     * @param  {function} onLoad     - On load callback
     * @param  {function} onProgress - In progress callback
     * @param  {function} onError    - On error callback
     * @return {THREE.Texture}   	 - Image texture
     */
    load: function (url, onLoad, onProgress, onError) {
      var texture = new THREE.Texture();

      ImageLoader.load(
        url,
        function (image) {
          texture.image = image;

          // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
          const isJPEG =
            url.search(/\.(jpg|jpeg)$/) > 0 ||
            url.search(/^data\:image\/jpeg/) === 0;

          texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
          texture.needsUpdate = true;

          onLoad && onLoad(texture);
        },
        onProgress,
        onError
      );

      return texture;
    },
  };

  /**
   * @module CubeTextureLoader
   * @description Cube Texture Loader based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/CubeTextureLoader.js}
   */
  const CubeTextureLoader = {
    /**
     * Load 6 images as a cube texture
     * @example PANOLENS.CubeTextureLoader.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] )
     * @method load
     * @param  {array}   urls        - array of 6 urls to images, one for each side of the CubeTexture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z
     * @param  {function} onLoad     - On load callback
     * @param  {function} onProgress - In progress callback
     * @param  {function} onError    - On error callback
     * @return {THREE.CubeTexture}   - Cube texture
     */
    load: function (urls, onLoad, onProgress, onError) {
      var texture, loaded, progress, all, loadings;

      texture = new THREE.CubeTexture([]);

      loaded = 0;
      progress = {};
      all = {};

      urls.map(function (url, index) {
        ImageLoader.load(
          url,
          function (image) {
            texture.images[index] = image;

            loaded++;

            if (loaded === 6) {
              texture.needsUpdate = true;

              onLoad && onLoad(texture);
            }
          },
          function (event) {
            progress[index] = { loaded: event.loaded, total: event.total };

            all.loaded = 0;
            all.total = 0;
            loadings = 0;

            for (var i in progress) {
              loadings++;
              all.loaded += progress[i].loaded;
              all.total += progress[i].total;
            }

            if (loadings < 6) {
              all.total = (all.total / loadings) * 6;
            }

            onProgress && onProgress(all);
          },
          onError
        );
      });

      return texture;
    },
  };

  /**
   * @classdesc User Media
   * @constructor
   * @param {object} [constraints={ video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: { exact: 'environment' } }, audio: false }]
   */
  function Media(constraints) {
    const defaultConstraints = {
      video: {
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        facingMode: { exact: "environment" },
      },
      audio: false,
    };

    this.constraints = Object.assign(defaultConstraints, constraints);

    this.container;
    this.scene;
    this.element;
    this.devices = [];
    this.stream;
    this.ratioScalar = 1;
    this.videoDeviceIndex = 0;
  }
  Object.assign(Media.prototype, {
    /**
     * Enumerate devices
     * @memberOf Media
     * @instance
     * @returns {Promise}
     */
    enumerateDevices: function () {
      const devices = this.devices;
      const resolvedPromise = new Promise((resolve) => {
        resolve(devices);
      });

      return devices.length > 0
        ? resolvedPromise
        : navigator.mediaDevices.enumerateDevices();
    },

    /**
     * Switch to next available video device
     * @memberOf Media
     * @instance
     */
    switchNextVideoDevice: function () {
      const stop = this.stop.bind(this);
      const start = this.start.bind(this);
      const setVideDeviceIndex = this.setVideDeviceIndex.bind(this);

      let index = this.videoDeviceIndex;

      this.getDevices("video").then((devices) => {
        stop();
        index++;
        if (index >= devices.length) {
          setVideDeviceIndex(0);
          index--;
        } else {
          setVideDeviceIndex(index);
        }

        start(devices[index]);
      });
    },

    /**
     * Get devices
     * @param {string} type - type keyword to match device.kind
     * @memberOf Media
     * @instance
     */
    getDevices: function (type = "video") {
      const devices = this.devices;
      const validate = (_devices) => {
        return _devices.map((device) => {
          !devices.includes(device) && devices.push(device);
          return device;
        });
      };
      const filter = (_devices) => {
        const reg = new RegExp(type, "i");
        return _devices.filter((device) => reg.test(device.kind));
      };

      return this.enumerateDevices().then(validate).then(filter);
    },

    /**
     * Get user media
     * @param {MediaStreamConstraints} constraints
     * @memberOf Media
     * @instance
     */
    getUserMedia: function (constraints) {
      const setMediaStream = this.setMediaStream.bind(this);
      const playVideo = this.playVideo.bind(this);
      const onCatchError = (error) => {
        console.warn(`PANOLENS.Media: ${error}`);
      };

      return navigator.mediaDevices
        .getUserMedia(constraints)
        .then(setMediaStream)
        .then(playVideo)
        .catch(onCatchError);
    },

    /**
     * Set video device index
     * @param {number} index
     * @memberOf Media
     * @instance
     */
    setVideDeviceIndex: function (index) {
      this.videoDeviceIndex = index;
    },

    /**
     * Start streaming
     * @param {MediaDeviceInfo} [targetDevice]
     * @memberOf Media
     * @instance
     */
    start: function (targetDevice) {
      const constraints = this.constraints;
      const getUserMedia = this.getUserMedia.bind(this);
      const onVideoDevices = (devices) => {
        if (!devices || devices.length === 0) {
          throw Error("no video device found");
        }

        const device = targetDevice || devices[0];
        constraints.video.deviceId = device.deviceId;

        return getUserMedia(constraints);
      };

      this.element = this.createVideoElement();

      return this.getDevices().then(onVideoDevices);
    },

    /**
     * Stop streaming
     * @memberOf Media
     * @instance
     */
    stop: function () {
      const stream = this.stream;

      if (stream && stream.active) {
        const track = stream.getTracks()[0];

        track.stop();

        window.removeEventListener("resize", this.onWindowResize.bind(this));

        this.element = null;
        this.stream = null;
      }
    },

    /**
     * Set media stream
     * @param {MediaStream} stream
     * @memberOf Media
     * @instance
     */
    setMediaStream: function (stream) {
      this.stream = stream;
      this.element.srcObject = stream;

      if (this.scene) {
        this.scene.background = this.createVideoTexture();
      }

      window.addEventListener("resize", this.onWindowResize.bind(this));
    },

    /**
     * Play video element
     * @memberOf Media
     * @instance
     */
    playVideo: function () {
      const { element } = this;

      if (element) {
        element.play();
      }
    },

    /**
     * Pause video element
     * @memberOf Media
     * @instance
     */
    pauseVideo: function () {
      const { element } = this;

      if (element) {
        element.pause();
      }
    },

    /**
     * Create video texture
     * @memberOf Media
     * @instance
     * @returns {THREE.VideoTexture}
     */
    createVideoTexture: function () {
      const video = this.element;
      const texture = new THREE.VideoTexture(video);

      texture.generateMipmaps = false;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;
      texture.center.set(0.5, 0.5);

      video.addEventListener("canplay", this.onWindowResize.bind(this));

      return texture;
    },

    /**
     * Create video element
     * @memberOf Media
     * @instance
     * @returns {HTMLVideoElement}
     */
    createVideoElement: function () {
      const video = document.createElement("video");

      video.setAttribute("autoplay", "");
      video.setAttribute("muted", "");
      video.setAttribute("playsinline", "");

      video.style.position = "absolute";
      video.style.top = "0";
      video.style.left = "0";
      video.style.width = "100%";
      video.style.height = "100%";
      video.style.objectPosition = "center";
      video.style.objectFit = "cover";
      video.style.display = this.scene ? "none" : "";

      return video;
    },

    /**
     * On window resize event
     * @param {Event} event
     * @memberOf Media
     * @instance
     */
    onWindowResize: function (event) {
      if (
        this.element &&
        this.element.videoWidth &&
        this.element.videoHeight &&
        this.scene
      ) {
        const { clientWidth: width, clientHeight: height } = this.container;
        const texture = this.scene.background;
        const { videoWidth, videoHeight } = this.element;
        const cameraRatio = videoHeight / videoWidth;
        const viewportRatio = this.container ? width / height : 1.0;
        const ratio = cameraRatio * viewportRatio * this.ratioScalar;

        if (width > height) {
          texture.repeat.set(ratio, 1);
        } else {
          texture.repeat.set(1, 1 / ratio);
        }
      }
    },
  });

  /**
   * @classdesc Reticle 3D Sprite
   * @constructor
   * @param {THREE.Color} [color=0xffffff] - Color of the reticle sprite
   * @param {boolean} [autoSelect=true] - Auto selection
   * @param {number} [dwellTime=1500] - Duration for dwelling sequence to complete
   */

  function Reticle(color = 0x77ffff, autoSelect = true, dwellTime = 1200) {
    this.dpr = window.devicePixelRatio;

    const { canvas, context } = this.createCanvas();
    const material = new THREE.SpriteMaterial({
      color,
      map: this.createCanvasTexture(canvas),
    });

    THREE.Sprite.call(this, material);

    this.canvasWidth = canvas.width;
    this.canvasHeight = canvas.height;
    this.context = context;
    this.color = color instanceof THREE.Color ? color : new THREE.Color(color);

    this.autoSelect = autoSelect;
    this.dwellTime = dwellTime;
    this.position.z = -5;
    this.center.set(0.5, 0.5);
    this.scale.set(1, 1, 1);

    this.startTimestamp;
    this.timerId;
    this.callback;

    this.frustumCulled = false;

    this.updateCanvasArcByProgress(0);
  }
  Reticle.prototype = Object.assign(Object.create(THREE.Sprite.prototype), {
    constructor: Reticle,

    /**
     * Set material color
     * @param {THREE.Color} color
     * @memberOf Reticle
     * @instance
     */
    setColor: function (color) {
      this.material.color.copy(
        color instanceof THREE.Color ? color : new THREE.Color(color)
      );
    },

    /**
     * Create canvas texture
     * @param {HTMLCanvasElement} canvas
     * @memberOf Reticle
     * @instance
     * @returns {THREE.CanvasTexture}
     */
    createCanvasTexture: function (canvas) {
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;

      return texture;
    },

    /**
     * Create canvas element
     * @memberOf Reticle
     * @instance
     * @returns {object} object
     * @returns {HTMLCanvasElement} object.canvas
     * @returns {CanvasRenderingContext2D} object.context
     */
    createCanvas: function () {
      const width = 32;
      const height = 32;
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      const dpr = this.dpr;

      canvas.width = width * dpr;
      canvas.height = height * dpr;
      context.scale(dpr, dpr);

      context.shadowBlur = 5;
      context.shadowColor = "rgba(200,200,200,0.9)";

      return { canvas, context };
    },

    /**
     * Update canvas arc by progress
     * @param {number} progress
     * @memberOf Reticle
     * @instance
     */
    updateCanvasArcByProgress: function (progress) {
      const context = this.context;
      const { canvasWidth, canvasHeight, material } = this;
      const dpr = this.dpr;
      const degree = progress * Math.PI * 2;
      const color = this.color.getStyle();
      const x = (canvasWidth * 0.5) / dpr;
      const y = (canvasHeight * 0.5) / dpr;
      const lineWidth = 3;

      context.clearRect(0, 0, canvasWidth, canvasHeight);
      context.beginPath();

      if (progress === 0) {
        context.arc(x, y, canvasWidth / 16, 0, 2 * Math.PI);
        context.fillStyle = color;
        context.fill();
      } else {
        context.arc(
          x,
          y,
          canvasWidth / 4 - lineWidth,
          -Math.PI / 2,
          -Math.PI / 2 + degree
        );
        context.strokeStyle = color;
        context.lineWidth = lineWidth;
        context.stroke();
      }

      context.closePath();

      material.map.needsUpdate = true;
    },

    /**
     * Ripple effect
     * @memberOf Reticle
     * @instance
     */
    ripple: function () {
      const context = this.context;
      const stop = this.stop.bind(this);
      const { canvasWidth, canvasHeight, material } = this;
      const duration = 500;
      const timestamp = performance.now();
      const color = this.color;
      const dpr = this.dpr;
      const x = (canvasWidth * 0.5) / dpr;
      const y = (canvasHeight * 0.5) / dpr;

      const update = () => {
        const timerId = requestAnimationFrame(update);
        const elapsed = performance.now() - timestamp;
        const progress = elapsed / duration;
        const opacity = 1.0 - progress > 0 ? 1.0 - progress : 0;
        const radius = (progress * canvasWidth * 0.5) / dpr;

        context.clearRect(0, 0, canvasWidth, canvasHeight);
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.fillStyle = `rgba(${color.r * 255}, ${color.g * 255}, ${
          color.b * 255
        }, ${opacity})`;
        context.fill();
        context.closePath();

        if (progress > 1.0) {
          cancelAnimationFrame(timerId);
          stop();
        }

        material.map.needsUpdate = true;
      };

      update();
    },

    /**
     * Make reticle visible
     * @memberOf Reticle
     * @instance
     */
    show: function () {
      this.visible = true;
    },

    /**
     * Make reticle invisible
     * @memberOf Reticle
     * @instance
     */
    hide: function () {
      this.visible = false;
    },

    /**
     * Start dwelling
     * @param {function} callback
     * @memberOf Reticle
     * @instance
     */
    start: function (callback) {
      if (!this.autoSelect) {
        return;
      }

      this.startTimestamp = performance.now();
      this.callback = callback;
      this.update();
    },

    /**
     * Stop dwelling
     * @memberOf Reticle
     * @instance
     */
    stop: function () {
      cancelAnimationFrame(this.timerId);

      this.updateCanvasArcByProgress(0);
      this.callback = null;
      this.timerId = null;
    },

    /**
     * Update dwelling
     * @memberOf Reticle
     * @instance
     */
    update: function () {
      this.timerId = requestAnimationFrame(this.update.bind(this));

      const elapsed = performance.now() - this.startTimestamp;
      const progress = elapsed / this.dwellTime;

      this.updateCanvasArcByProgress(progress);

      if (progress > 1.0) {
        cancelAnimationFrame(this.timerId);
        this.ripple();
        this.callback && this.callback();
        this.stop();
      }
    },
  });

  var commonjsGlobal =
    typeof globalThis !== "undefined"
      ? globalThis
      : typeof window !== "undefined"
      ? window
      : typeof global !== "undefined"
      ? global
      : typeof self !== "undefined"
      ? self
      : {};

  function createCommonjsModule(fn, module) {
    return (
      (module = { exports: {} }), fn(module, module.exports), module.exports
    );
  }

  var Tween = createCommonjsModule(function (module, exports) {
    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */

    var _Group = function () {
      this._tweens = {};
      this._tweensAddedDuringUpdate = {};
    };

    _Group.prototype = {
      getAll: function () {
        return Object.keys(this._tweens).map(
          function (tweenId) {
            return this._tweens[tweenId];
          }.bind(this)
        );
      },

      removeAll: function () {
        this._tweens = {};
      },

      add: function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
      },

      remove: function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
      },

      update: function (time, preserve) {
        var tweenIds = Object.keys(this._tweens);

        if (tweenIds.length === 0) {
          return false;
        }

        time = time !== undefined ? time : TWEEN.now();

        // Tweens are updated in "batches". If you add a new tween during an update, then the
        // new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated. However,
        // if the removed tween was added during the current batch, then it will not be updated.
        while (tweenIds.length > 0) {
          this._tweensAddedDuringUpdate = {};

          for (var i = 0; i < tweenIds.length; i++) {
            var tween = this._tweens[tweenIds[i]];

            if (tween && tween.update(time) === false) {
              tween._isPlaying = false;

              if (!preserve) {
                delete this._tweens[tweenIds[i]];
              }
            }
          }

          tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }

        return true;
      },
    };

    var TWEEN = new _Group();

    TWEEN.Group = _Group;
    TWEEN._nextId = 0;
    TWEEN.nextId = function () {
      return TWEEN._nextId++;
    };

    // Include a performance.now polyfill.
    // In node.js, use process.hrtime.
    if (
      typeof self === "undefined" &&
      typeof process !== "undefined" &&
      process.hrtime
    ) {
      TWEEN.now = function () {
        var time = process.hrtime();

        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
      };
    }
    // In a browser, use self.performance.now if it is available.
    else if (
      typeof self !== "undefined" &&
      self.performance !== undefined &&
      self.performance.now !== undefined
    ) {
      // This must be bound, because directly assigning this function
      // leads to an invocation exception in Chrome.
      TWEEN.now = self.performance.now.bind(self.performance);
    }
    // Use Date.now if it is available.
    else if (Date.now !== undefined) {
      TWEEN.now = Date.now;
    }
    // Otherwise, use 'new Date().getTime()'.
    else {
      TWEEN.now = function () {
        return new Date().getTime();
      };
    }

    TWEEN.Tween = function (object, group) {
      this._object = object;
      this._valuesStart = {};
      this._valuesEnd = {};
      this._valuesStartRepeat = {};
      this._duration = 1000;
      this._repeat = 0;
      this._repeatDelayTime = undefined;
      this._yoyo = false;
      this._isPlaying = false;
      this._reversed = false;
      this._delayTime = 0;
      this._startTime = null;
      this._easingFunction = TWEEN.Easing.Linear.None;
      this._interpolationFunction = TWEEN.Interpolation.Linear;
      this._chainedTweens = [];
      this._onStartCallback = null;
      this._onStartCallbackFired = false;
      this._onUpdateCallback = null;
      this._onRepeatCallback = null;
      this._onCompleteCallback = null;
      this._onStopCallback = null;
      this._group = group || TWEEN;
      this._id = TWEEN.nextId();
    };

    TWEEN.Tween.prototype = {
      getId: function () {
        return this._id;
      },

      isPlaying: function () {
        return this._isPlaying;
      },

      to: function (properties, duration) {
        this._valuesEnd = Object.create(properties);

        if (duration !== undefined) {
          this._duration = duration;
        }

        return this;
      },

      duration: function duration(d) {
        this._duration = d;
        return this;
      },

      start: function (time) {
        this._group.add(this);

        this._isPlaying = true;

        this._onStartCallbackFired = false;

        this._startTime =
          time !== undefined
            ? typeof time === "string"
              ? TWEEN.now() + parseFloat(time)
              : time
            : TWEEN.now();
        this._startTime += this._delayTime;

        for (var property in this._valuesEnd) {
          // Check if an Array was provided as property value
          if (this._valuesEnd[property] instanceof Array) {
            if (this._valuesEnd[property].length === 0) {
              continue;
            }

            // Create a local copy of the Array with the start value at the front
            this._valuesEnd[property] = [this._object[property]].concat(
              this._valuesEnd[property]
            );
          }

          // If `to()` specifies a property that doesn't exist in the source object,
          // we should not set that property in the object
          if (this._object[property] === undefined) {
            continue;
          }

          // Save the starting value.
          this._valuesStart[property] = this._object[property];

          if (this._valuesStart[property] instanceof Array === false) {
            this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
          }

          this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
        }

        return this;
      },

      stop: function () {
        if (!this._isPlaying) {
          return this;
        }

        this._group.remove(this);
        this._isPlaying = false;

        if (this._onStopCallback !== null) {
          this._onStopCallback(this._object);
        }

        this.stopChainedTweens();
        return this;
      },

      end: function () {
        this.update(Infinity);
        return this;
      },

      stopChainedTweens: function () {
        for (
          var i = 0, numChainedTweens = this._chainedTweens.length;
          i < numChainedTweens;
          i++
        ) {
          this._chainedTweens[i].stop();
        }
      },

      group: function (group) {
        this._group = group;
        return this;
      },

      delay: function (amount) {
        this._delayTime = amount;
        return this;
      },

      repeat: function (times) {
        this._repeat = times;
        return this;
      },

      repeatDelay: function (amount) {
        this._repeatDelayTime = amount;
        return this;
      },

      yoyo: function (yoyo) {
        this._yoyo = yoyo;
        return this;
      },

      easing: function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
      },

      interpolation: function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
      },

      chain: function () {
        this._chainedTweens = arguments;
        return this;
      },

      onStart: function (callback) {
        this._onStartCallback = callback;
        return this;
      },

      onUpdate: function (callback) {
        this._onUpdateCallback = callback;
        return this;
      },

      onRepeat: function onRepeat(callback) {
        this._onRepeatCallback = callback;
        return this;
      },

      onComplete: function (callback) {
        this._onCompleteCallback = callback;
        return this;
      },

      onStop: function (callback) {
        this._onStopCallback = callback;
        return this;
      },

      update: function (time) {
        var property;
        var elapsed;
        var value;

        if (time < this._startTime) {
          return true;
        }

        if (this._onStartCallbackFired === false) {
          if (this._onStartCallback !== null) {
            this._onStartCallback(this._object);
          }

          this._onStartCallbackFired = true;
        }

        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;

        value = this._easingFunction(elapsed);

        for (property in this._valuesEnd) {
          // Don't update properties that do not exist in the source object
          if (this._valuesStart[property] === undefined) {
            continue;
          }

          var start = this._valuesStart[property] || 0;
          var end = this._valuesEnd[property];

          if (end instanceof Array) {
            this._object[property] = this._interpolationFunction(end, value);
          } else {
            // Parses relative end values with start as base (e.g.: +10, -3)
            if (typeof end === "string") {
              if (end.charAt(0) === "+" || end.charAt(0) === "-") {
                end = start + parseFloat(end);
              } else {
                end = parseFloat(end);
              }
            }

            // Protect against non numeric properties.
            if (typeof end === "number") {
              this._object[property] = start + (end - start) * value;
            }
          }
        }

        if (this._onUpdateCallback !== null) {
          this._onUpdateCallback(this._object, elapsed);
        }

        if (elapsed === 1) {
          if (this._repeat > 0) {
            if (isFinite(this._repeat)) {
              this._repeat--;
            }

            // Reassign starting values, restart by making startTime = now
            for (property in this._valuesStartRepeat) {
              if (typeof this._valuesEnd[property] === "string") {
                this._valuesStartRepeat[property] =
                  this._valuesStartRepeat[property] +
                  parseFloat(this._valuesEnd[property]);
              }

              if (this._yoyo) {
                var tmp = this._valuesStartRepeat[property];

                this._valuesStartRepeat[property] = this._valuesEnd[property];
                this._valuesEnd[property] = tmp;
              }

              this._valuesStart[property] = this._valuesStartRepeat[property];
            }

            if (this._yoyo) {
              this._reversed = !this._reversed;
            }

            if (this._repeatDelayTime !== undefined) {
              this._startTime = time + this._repeatDelayTime;
            } else {
              this._startTime = time + this._delayTime;
            }

            if (this._onRepeatCallback !== null) {
              this._onRepeatCallback(this._object);
            }

            return true;
          } else {
            if (this._onCompleteCallback !== null) {
              this._onCompleteCallback(this._object);
            }

            for (
              var i = 0, numChainedTweens = this._chainedTweens.length;
              i < numChainedTweens;
              i++
            ) {
              // Make the chained tweens start exactly at the time they should,
              // even if the `update()` method was called way past the duration of the tween
              this._chainedTweens[i].start(this._startTime + this._duration);
            }

            return false;
          }
        }

        return true;
      },
    };

    TWEEN.Easing = {
      Linear: {
        None: function (k) {
          return k;
        },
      },

      Quadratic: {
        In: function (k) {
          return k * k;
        },

        Out: function (k) {
          return k * (2 - k);
        },

        InOut: function (k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k;
          }

          return -0.5 * (--k * (k - 2) - 1);
        },
      },

      Cubic: {
        In: function (k) {
          return k * k * k;
        },

        Out: function (k) {
          return --k * k * k + 1;
        },

        InOut: function (k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
          }

          return 0.5 * ((k -= 2) * k * k + 2);
        },
      },

      Quartic: {
        In: function (k) {
          return k * k * k * k;
        },

        Out: function (k) {
          return 1 - --k * k * k * k;
        },

        InOut: function (k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
          }

          return -0.5 * ((k -= 2) * k * k * k - 2);
        },
      },

      Quintic: {
        In: function (k) {
          return k * k * k * k * k;
        },

        Out: function (k) {
          return --k * k * k * k * k + 1;
        },

        InOut: function (k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
          }

          return 0.5 * ((k -= 2) * k * k * k * k + 2);
        },
      },

      Sinusoidal: {
        In: function (k) {
          return 1 - Math.cos((k * Math.PI) / 2);
        },

        Out: function (k) {
          return Math.sin((k * Math.PI) / 2);
        },

        InOut: function (k) {
          return 0.5 * (1 - Math.cos(Math.PI * k));
        },
      },

      Exponential: {
        In: function (k) {
          return k === 0 ? 0 : Math.pow(1024, k - 1);
        },

        Out: function (k) {
          return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },

        InOut: function (k) {
          if (k === 0) {
            return 0;
          }

          if (k === 1) {
            return 1;
          }

          if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
          }

          return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        },
      },

      Circular: {
        In: function (k) {
          return 1 - Math.sqrt(1 - k * k);
        },

        Out: function (k) {
          return Math.sqrt(1 - --k * k);
        },

        InOut: function (k) {
          if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
          }

          return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
      },

      Elastic: {
        In: function (k) {
          if (k === 0) {
            return 0;
          }

          if (k === 1) {
            return 1;
          }

          return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        },

        Out: function (k) {
          if (k === 0) {
            return 0;
          }

          if (k === 1) {
            return 1;
          }

          return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
        },

        InOut: function (k) {
          if (k === 0) {
            return 0;
          }

          if (k === 1) {
            return 1;
          }

          k *= 2;

          if (k < 1) {
            return (
              -0.5 *
              Math.pow(2, 10 * (k - 1)) *
              Math.sin((k - 1.1) * 5 * Math.PI)
            );
          }

          return (
            0.5 *
              Math.pow(2, -10 * (k - 1)) *
              Math.sin((k - 1.1) * 5 * Math.PI) +
            1
          );
        },
      },

      Back: {
        In: function (k) {
          var s = 1.70158;

          return k * k * ((s + 1) * k - s);
        },

        Out: function (k) {
          var s = 1.70158;

          return --k * k * ((s + 1) * k + s) + 1;
        },

        InOut: function (k) {
          var s = 1.70158 * 1.525;

          if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
          }

          return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
      },

      Bounce: {
        In: function (k) {
          return 1 - TWEEN.Easing.Bounce.Out(1 - k);
        },

        Out: function (k) {
          if (k < 1 / 2.75) {
            return 7.5625 * k * k;
          } else if (k < 2 / 2.75) {
            return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
          } else if (k < 2.5 / 2.75) {
            return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
          } else {
            return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
          }
        },

        InOut: function (k) {
          if (k < 0.5) {
            return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
          }

          return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        },
      },
    };

    TWEEN.Interpolation = {
      Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN.Interpolation.Utils.Linear;

        if (k < 0) {
          return fn(v[0], v[1], f);
        }

        if (k > 1) {
          return fn(v[m], v[m - 1], m - f);
        }

        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
      },

      Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = TWEEN.Interpolation.Utils.Bernstein;

        for (var i = 0; i <= n; i++) {
          b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }

        return b;
      },

      CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN.Interpolation.Utils.CatmullRom;

        if (v[0] === v[m]) {
          if (k < 0) {
            i = Math.floor((f = m * (1 + k)));
          }

          return fn(
            v[(i - 1 + m) % m],
            v[i],
            v[(i + 1) % m],
            v[(i + 2) % m],
            f - i
          );
        } else {
          if (k < 0) {
            return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
          }

          if (k > 1) {
            return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
          }

          return fn(
            v[i ? i - 1 : 0],
            v[i],
            v[m < i + 1 ? m : i + 1],
            v[m < i + 2 ? m : i + 2],
            f - i
          );
        }
      },

      Utils: {
        Linear: function (p0, p1, t) {
          return (p1 - p0) * t + p0;
        },

        Bernstein: function (n, i) {
          var fc = TWEEN.Interpolation.Utils.Factorial;

          return fc(n) / fc(i) / fc(n - i);
        },

        Factorial: (function () {
          var a = [1];

          return function (n) {
            var s = 1;

            if (a[n]) {
              return a[n];
            }

            for (var i = n; i > 1; i--) {
              s *= i;
            }

            a[n] = s;
            return s;
          };
        })(),

        CatmullRom: function (p0, p1, p2, p3, t) {
          var v0 = (p2 - p0) * 0.5;
          var v1 = (p3 - p1) * 0.5;
          var t2 = t * t;
          var t3 = t * t2;

          return (
            (2 * p1 - 2 * p2 + v0 + v1) * t3 +
            (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
            v0 * t +
            p1
          );
        },
      },
    };

    // UMD (Universal Module Definition)
    (function (root) {
      {
        // Node.js
        module.exports = TWEEN;
      }
    })(commonjsGlobal);
  });

  /**
   * @classdesc Information spot attached to panorama
   * @constructor
   * @param {number} [scale=300] - Default scale
   * @param {string} [imageSrc=PANOLENS.DataImage.Info] - Image overlay info
   * @param {boolean} [animated=true] - Enable default hover animation
   */
  function Infospot(scale = 300, imageSrc, animated) {
    const duration = 1000,
      scaleFactor = 3;

    imageSrc = imageSrc || DataImage.Info;

    THREE.Sprite.call(this);

    this.type = "infospot";

    this.animated = animated !== undefined ? animated : true;
    this.isHovering = false;

    /*
     * TODO: Three.js bug hotfix for sprite raycasting r104
     * https://github.com/mrdoob/three.js/issues/14624
     */
    this.frustumCulled = false;

    this.element;
    this.toPanorama;
    this.cursorStyle;

    this.mode = MODES.UNKNOWN;

    this.scale.set(scale, scale, 1);
    this.rotation.y = Math.PI;

    this.container;

    this.originalRaycast = this.raycast;

    // Event Handler
    this.HANDLER_FOCUS;

    this.material.side = THREE.DoubleSide;
    this.material.depthTest = false;
    this.material.transparent = true;
    this.material.opacity = 0;

    const postLoad = function (texture) {
      const ratio = texture.image.width / texture.image.height;
      const textureScale = new THREE.Vector3();

      texture.image.width = texture.image.naturalWidth || 64;
      texture.image.height = texture.image.naturalHeight || 64;

      this.scale.set(ratio * scale, scale, 1);

      textureScale.copy(this.scale);

      this.scaleUpAnimation = new Tween.Tween(this.scale)
        .to(
          { x: textureScale.x * scaleFactor, y: textureScale.y * scaleFactor },
          duration
        )
        .easing(Tween.Easing.Elastic.Out);

      this.scaleDownAnimation = new Tween.Tween(this.scale)
        .to({ x: textureScale.x, y: textureScale.y }, duration)
        .easing(Tween.Easing.Elastic.Out);

      this.material.map = texture;
      this.material.needsUpdate = true;
    }.bind(this);

    // Add show and hide animations
    this.showAnimation = new Tween.Tween(this.material)
      .to({ opacity: 1 }, duration)
      .onStart(this.enableRaycast.bind(this, true))
      .easing(Tween.Easing.Quartic.Out);

    this.hideAnimation = new Tween.Tween(this.material)
      .to({ opacity: 0 }, duration)
      .onStart(this.enableRaycast.bind(this, false))
      .easing(Tween.Easing.Quartic.Out);

    // Attach event listeners
    this.addEventListener("click", this.onClick);
    this.addEventListener("hover", this.onHover);
    this.addEventListener("hoverenter", this.onHoverStart);
    this.addEventListener("hoverleave", this.onHoverEnd);
    this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect);
    this.addEventListener("panolens-container", this.setContainer.bind(this));
    this.addEventListener("dismiss", this.onDismiss);
    this.addEventListener("panolens-infospot-focus", this.setFocusMethod);

    TextureLoader.load(imageSrc, postLoad);
  }
  Infospot.prototype = Object.assign(Object.create(THREE.Sprite.prototype), {
    constructor: Infospot,

    /**
     * Set infospot container
     * @param {HTMLElement|object} data - Data with container information
     * @memberOf Infospot
     * @instance
     */
    setContainer: function (data) {
      let container;

      if (data instanceof HTMLElement) {
        container = data;
      } else if (data && data.container) {
        container = data.container;
      }

      // Append element if exists
      if (container && this.element) {
        container.appendChild(this.element);
      }

      this.container = container;
    },

    /**
     * Get container
     * @memberOf Infospot
     * @instance
     * @return {HTMLElement} - The container of this infospot
     */
    getContainer: function () {
      return this.container;
    },

    /**
     * This will be called by a click event
     * Translate and lock the hovering element if any
     * @param  {object} event - Event containing mouseEvent with clientX and clientY
     * @memberOf Infospot
     * @instance
     */
    onClick: function (event) {
      if (this.element && this.getContainer()) {
        this.onHoverStart(event);

        // Lock element
        this.lockHoverElement();
      }
    },

    /**
     * Dismiss current element if any
     * @param  {object} event - Dismiss event
     * @memberOf Infospot
     * @instance
     */
    onDismiss: function (event) {
      if (this.element) {
        this.unlockHoverElement();
        this.onHoverEnd();
      }
    },

    /**
     * This will be called by a mouse hover event
     * Translate the hovering element if any
     * @param  {object} event - Event containing mouseEvent with clientX and clientY
     * @memberOf Infospot
     * @instance
     */
    onHover: function (event) {},

    /**
     * This will be called on a mouse hover start
     * Sets cursor style to 'pointer', display the element and scale up the infospot
     * @param {object} event
     * @memberOf Infospot
     * @instance
     */
    onHoverStart: function (event) {
      if (!this.getContainer()) {
        return;
      }

      const cursorStyle =
        this.cursorStyle ||
        (this.mode === MODES.NORMAL ? "pointer" : "default");

      this.isHovering = true;
      this.container.style.cursor = cursorStyle;

      if (this.animated) {
        this.scaleDownAnimation && this.scaleDownAnimation.stop();
        this.scaleUpAnimation && this.scaleUpAnimation.start();
      }

      if (
        this.element &&
        event.mouseEvent.clientX >= 0 &&
        event.mouseEvent.clientY >= 0
      ) {
        if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
          this.element.style.display = "none";
          this.element.left && (this.element.left.style.display = "block");
          this.element.right && (this.element.right.style.display = "block");

          // Store element width for reference
          this.element._width = this.element.left.clientWidth;
          this.element._height = this.element.left.clientHeight;
        } else {
          this.element.style.display = "block";
          this.element.left && (this.element.left.style.display = "none");
          this.element.right && (this.element.right.style.display = "none");

          // Store element width for reference
          this.element._width = this.element.clientWidth;
          this.element._height = this.element.clientHeight;
        }
      }
    },

    /**
     * This will be called on a mouse hover end
     * Sets cursor style to 'default', hide the element and scale down the infospot
     * @memberOf Infospot
     * @instance
     */
    onHoverEnd: function () {
      if (!this.getContainer()) {
        return;
      }

      this.isHovering = false;
      this.container.style.cursor = "default";

      if (this.animated) {
        this.scaleUpAnimation && this.scaleUpAnimation.stop();
        this.scaleDownAnimation && this.scaleDownAnimation.start();
      }

      if (this.element && !this.element.locked) {
        this.element.style.display = "none";
        this.element.left && (this.element.left.style.display = "none");
        this.element.right && (this.element.right.style.display = "none");

        this.unlockHoverElement();
      }
    },

    /**
     * On dual eye effect handler
     * Creates duplicate left and right element
     * @param  {object} event - panolens-dual-eye-effect event
     * @memberOf Infospot
     * @instance
     */
    onDualEyeEffect: function (event) {
      if (!this.getContainer()) {
        return;
      }

      let element, halfWidth, halfHeight;

      this.mode = event.mode;

      element = this.element;

      halfWidth = this.container.clientWidth / 2;
      halfHeight = this.container.clientHeight / 2;

      if (!element) {
        return;
      }

      if (!element.left || !element.right) {
        element.left = element.cloneNode(true);
        element.right = element.cloneNode(true);
      }

      if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
        element.left.style.display = element.style.display;
        element.right.style.display = element.style.display;
        element.style.display = "none";
      } else {
        element.style.display = element.left.style.display;
        element.left.style.display = "none";
        element.right.style.display = "none";
      }

      // Update elements translation
      this.translateElement(halfWidth, halfHeight);

      this.container.appendChild(element.left);
      this.container.appendChild(element.right);
    },

    /**
     * Translate the hovering element by css transform
     * @param  {number} x - X position on the window screen
     * @param  {number} y - Y position on the window screen
     * @memberOf Infospot
     * @instance
     */
    translateElement: function (x, y) {
      if (
        !this.element._width ||
        !this.element._height ||
        !this.getContainer()
      ) {
        return;
      }

      let left, top, element, width, height, delta, container;

      container = this.container;
      element = this.element;
      width = element._width / 2;
      height = element._height / 2;
      delta = element.verticalDelta !== undefined ? element.verticalDelta : 40;

      left = x - width;
      top = y - height - delta;

      if (
        (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) &&
        element.left &&
        element.right &&
        !(x === container.clientWidth / 2 && y === container.clientHeight / 2)
      ) {
        left =
          container.clientWidth / 4 - width + (x - container.clientWidth / 2);
        top =
          container.clientHeight / 2 -
          height -
          delta +
          (y - container.clientHeight / 2);

        this.setElementStyle(
          "transform",
          element.left,
          "translate(" + left + "px, " + top + "px)"
        );

        left += container.clientWidth / 2;

        this.setElementStyle(
          "transform",
          element.right,
          "translate(" + left + "px, " + top + "px)"
        );
      } else {
        this.setElementStyle(
          "transform",
          element,
          "translate(" + left + "px, " + top + "px)"
        );
      }
    },

    /**
     * Set vendor specific css
     * @param {string} type - CSS style name
     * @param {HTMLElement} element - The element to be modified
     * @param {string} value - Style value
     * @memberOf Infospot
     * @instance
     */
    setElementStyle: function (type, element, value) {
      const style = element.style;

      if (type === "transform") {
        style.webkitTransform = style.msTransform = style.transform = value;
      }
    },

    /**
     * Set hovering text content
     * @param {string} text - Text to be displayed
     * @memberOf Infospot
     * @instance
     */
    setText: function (text) {
      if (this.element) {
        this.element.textContent = text;
      }
    },

    /**
     * Set cursor css style on hover
     * @memberOf Infospot
     * @instance
     */
    setCursorHoverStyle: function (style) {
      this.cursorStyle = style;
    },

    /**
     * Add hovering text element
     * @param {string} text - Text to be displayed
     * @param {number} [delta=40] - Vertical delta to the infospot
     * @memberOf Infospot
     * @instance
     */
    addHoverText: function (text, delta) {
      if (!this.element) {
        this.element = document.createElement("div");
        this.element.style.display = "none";
        this.element.style.color = "#fff";
        this.element.style.top = 0;
        this.element.style.maxWidth = "50%";
        this.element.style.maxHeight = "50%";
        this.element.style.textShadow = "0 0 3px #000000";
        this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif';
        this.element.style.position = "absolute";
        this.element.classList.add("panolens-infospot");
        this.element.verticalDelta = delta !== undefined ? delta : 40;
      }

      this.setText(text);
    },

    /**
     * Add hovering element by cloning an element
     * @param {HTMLDOMElement} el - Element to be cloned and displayed
     * @param {number} [delta=40] - Vertical delta to the infospot
     * @memberOf Infospot
     * @instance
     */
    addHoverElement: function (el, delta) {
      if (!this.element) {
        this.element = el.cloneNode(true);
        this.element.style.display = "none";
        this.element.style.top = 0;
        this.element.style.position = "absolute";
        this.element.classList.add("panolens-infospot");
        this.element.verticalDelta = delta !== undefined ? delta : 40;
      }
    },

    /**
     * Remove hovering element
     * @memberOf Infospot
     * @instance
     */
    removeHoverElement: function () {
      if (this.element) {
        if (this.element.left) {
          this.container.removeChild(this.element.left);
          this.element.left = null;
        }

        if (this.element.right) {
          this.container.removeChild(this.element.right);
          this.element.right = null;
        }

        this.container.removeChild(this.element);
        this.element = null;
      }
    },

    /**
     * Lock hovering element
     * @memberOf Infospot
     * @instance
     */
    lockHoverElement: function () {
      if (this.element) {
        this.element.locked = true;
      }
    },

    /**
     * Unlock hovering element
     * @memberOf Infospot
     * @instance
     */
    unlockHoverElement: function () {
      if (this.element) {
        this.element.locked = false;
      }
    },

    /**
     * Enable raycasting
     * @param {boolean} [enabled=true]
     * @memberOf Infospot
     * @instance
     */
    enableRaycast: function (enabled = true) {
      if (enabled) {
        this.raycast = this.originalRaycast;
      } else {
        this.raycast = () => {};
      }
    },

    /**
     * Show infospot
     * @param  {number} [delay=0] - Delay time to show
     * @memberOf Infospot
     * @instance
     */
    show: function (delay = 0) {
      if (this.animated) {
        this.hideAnimation && this.hideAnimation.stop();
        this.showAnimation && this.showAnimation.delay(delay).start();
      } else {
        this.material.opacity = 1;
      }
    },

    /**
     * Hide infospot
     * @param  {number} [delay=0] - Delay time to hide
     * @memberOf Infospot
     * @instance
     */
    hide: function (delay = 0) {
      if (this.animated) {
        this.showAnimation && this.showAnimation.stop();
        this.hideAnimation && this.hideAnimation.delay(delay).start();
      } else {
        this.material.opacity = 0;
      }
    },

    /**
     * Set focus event handler
     * @memberOf Infospot
     * @instance
     */
    setFocusMethod: function (event) {
      if (event) {
        this.HANDLER_FOCUS = event.method;
      }
    },

    /**
     * Focus camera center to this infospot
     * @param {number} [duration=1000] - Duration to tween
     * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
     * @memberOf Infospot
     * @instance
     */
    focus: function (duration, easing) {
      if (this.HANDLER_FOCUS) {
        this.HANDLER_FOCUS(this.position, duration, easing);
        this.onDismiss();
      }
    },

    /**
     * Dispose
     * @memberOf Infospot
     * @instance
     */
    dispose: function () {
      this.removeHoverElement();
      this.material.dispose();

      if (this.parent) {
        this.parent.remove(this);
      }
    },
  });

  /**
   * @classdesc Widget for controls
   * @constructor
   * @param {HTMLElement} container - A domElement where default control widget will be attached to
   */
  function Widget(container) {
    if (!container) {
      console.warn("PANOLENS.Widget: No container specified");
    }

    THREE.EventDispatcher.call(this);

    this.DEFAULT_TRANSITION = "all 0.27s ease";
    this.TOUCH_ENABLED = !!(
      "ontouchstart" in window ||
      (window.DocumentTouch && document instanceof DocumentTouch)
    );
    this.PREVENT_EVENT_HANDLER = function (event) {
      event.preventDefault();
      event.stopPropagation();
    };

    this.container = container;

    this.barElement;
    this.fullscreenElement;
    this.videoElement;
    this.settingElement;

    this.mainMenu;

    this.activeMainItem;
    this.activeSubMenu;
    this.mask;
  }

  Widget.prototype = Object.assign(
    Object.create(THREE.EventDispatcher.prototype),
    {
      constructor: Widget,

      /**
       * Add control bar
       * @memberOf Widget
       * @instance
       */
      addControlBar: function () {
        if (!this.container) {
          console.warn("Widget container not set");
          return;
        }

        var scope = this,
          bar,
          styleTranslate,
          styleOpacity,
          gradientStyle;

        gradientStyle =
          "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))";

        bar = document.createElement("div");
        bar.style.width = "100%";
        bar.style.height = "44px";
        bar.style.float = "left";
        bar.style.transform = bar.style.webkitTransform = bar.style.msTransform =
          "translateY(-100%)";
        bar.style.background = "-webkit-" + gradientStyle;
        bar.style.background = "-moz-" + gradientStyle;
        bar.style.background = "-o-" + gradientStyle;
        bar.style.background = "-ms-" + gradientStyle;
        bar.style.background = gradientStyle;
        bar.style.transition = this.DEFAULT_TRANSITION;
        bar.style.pointerEvents = "none";
        bar.isHidden = false;
        bar.toggle = function () {
          bar.isHidden = !bar.isHidden;
          styleTranslate = bar.isHidden ? "translateY(0)" : "translateY(-100%)";
          styleOpacity = bar.isHidden ? 0 : 1;
          bar.style.transform = bar.style.webkitTransform = bar.style.msTransform = styleTranslate;
          bar.style.opacity = styleOpacity;
        };

        // Menu
        var menu = this.createDefaultMenu();
        this.mainMenu = this.createMainMenu(menu);
        bar.appendChild(this.mainMenu);

        // Mask
        var mask = this.createMask();
        this.mask = mask;
        this.container.appendChild(mask);

        // Dispose
        bar.dispose = function () {
          if (scope.fullscreenElement) {
            bar.removeChild(scope.fullscreenElement);
            scope.fullscreenElement.dispose();
            scope.fullscreenElement = null;
          }

          if (scope.settingElement) {
            bar.removeChild(scope.settingElement);
            scope.settingElement.dispose();
            scope.settingElement = null;
          }

          if (scope.videoElement) {
            bar.removeChild(scope.videoElement);
            scope.videoElement.dispose();
            scope.videoElement = null;
          }

          if (scope.compassElement) {
            bar.removeChild(scope.compassElement);
            scope.videoElement.dispose();
            scope.videoElement = null;
          }
        };

        this.container.appendChild(bar);

        // Mask events
        this.mask.addEventListener(
          "mousemove",
          this.PREVENT_EVENT_HANDLER,
          true
        );
        this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, true);
        this.mask.addEventListener(
          "mousedown",
          this.PREVENT_EVENT_HANDLER,
          true
        );
        this.mask.addEventListener(
          scope.TOUCH_ENABLED ? "touchend" : "click",
          function (event) {
            event.preventDefault();
            event.stopPropagation();

            scope.mask.hide();
            scope.settingElement.deactivate();
          },
          false
        );

        // Event listener
        this.addEventListener("control-bar-toggle", bar.toggle);

        this.barElement = bar;
      },

      /**
       * Create default menu
       * @memberOf Widget
       * @instance
       */
      createDefaultMenu: function () {
        var scope = this,
          handler;

        handler = function (method, data) {
          return function () {
            scope.dispatchEvent({
              type: "panolens-viewer-handler",
              method: method,
              data: data,
            });
          };
        };

        return [
          {
            title: "Control",
            subMenu: [
              {
                title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
                handler: handler("enableControl", CONTROLS.ORBIT),
              },
              {
                title: "Sensor",
                handler: handler("enableControl", CONTROLS.DEVICEORIENTATION),
              },
            ],
          },

          {
            title: "Mode",
            subMenu: [
              {
                title: "Normal",
                handler: handler("disableEffect"),
              },
              {
                title: "Cardboard",
                handler: handler("enableEffect", MODES.CARDBOARD),
              },
              {
                title: "Stereoscopic",
                handler: handler("enableEffect", MODES.STEREO),
              },
            ],
          },
        ];
      },

      /**
       * Add buttons on top of control bar
       * @param {string} name - The control button name to be created
       * @memberOf Widget
       * @instance
       */
      addControlButton: function (name) {
        let element;

        switch (name) {
          case "fullscreen":
            element = this.createFullscreenButton();
            this.fullscreenElement = element;

            break;

          case "setting":
            element = this.createSettingButton();
            this.settingElement = element;

            break;

          case "video":
            element = this.createVideoControl();
            this.videoElement = element;

            break;

          /*
					Author: silqwer
					compass layout
			*/
          case "compass":
            element = this.createCompass();
            this.compassElement = element;

            break;

          default:
            return;
        }

        if (!element) {
          return;
        }

        this.barElement.appendChild(element);
      },

      /**
       * Create modal mask
       * @memberOf Widget
       * @instance
       */
      createMask: function () {
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.width = "100%";
        element.style.height = "100%";
        element.style.background = "transparent";
        element.style.display = "none";

        element.show = function () {
          this.style.display = "block";
        };

        element.hide = function () {
          this.style.display = "none";
        };

        return element;
      },

      /**
       * Create Setting button to toggle menu
       * @memberOf Widget
       * @instance
       */
      createSettingButton: function () {
        let scope = this,
          item;

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          scope.mainMenu.toggle();

          if (this.activated) {
            this.deactivate();
          } else {
            this.activate();
          }
        }

        item = this.createCustomItem({
          style: {
            backgroundImage: 'url("' + DataImage.Setting + '")',
            webkitTransition: this.DEFAULT_TRANSITION,
            transition: this.DEFAULT_TRANSITION,
			position: "relative",
			right:"-20px",
          },

          onTap: onTap,
        });

        item.activate = function () {
          this.style.transform = "rotate3d(0,0,1,90deg)";
          this.activated = true;
          scope.mask.show();
        };

        item.deactivate = function () {
          this.style.transform = "rotate3d(0,0,0,0)";
          this.activated = false;
          scope.mask.hide();

          if (scope.mainMenu && scope.mainMenu.visible) {
            scope.mainMenu.hide();
          }

          if (scope.activeSubMenu && scope.activeSubMenu.visible) {
            scope.activeSubMenu.hide();
          }

          if (scope.mainMenu && scope.mainMenu._width) {
            scope.mainMenu.changeSize(scope.mainMenu._width);
            scope.mainMenu.unslideAll();
          }
        };

        item.activated = false;

        return item;
      },

      /**
       * Create Fullscreen button
       * @return {HTMLSpanElement} - The dom element icon for fullscreen
       * @memberOf Widget
       * @instance
       * @fires Widget#panolens-viewer-handler
       */
      createFullscreenButton: function () {
        let scope = this,
          item,
          isFullscreen = false,
          tapSkipped = true,
          stylesheetId;

        stylesheetId = "panolens-style-addon";

        // Don't create button if no support
        if (
          !document.fullscreenEnabled &&
          !document.webkitFullscreenEnabled &&
          !document.mozFullScreenEnabled &&
          !document.msFullscreenEnabled
        ) {
          return;
        }

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          tapSkipped = false;

          if (!isFullscreen) {
            scope.container.requestFullscreen &&
              scope.container.requestFullscreen();
            scope.container.msRequestFullscreen &&
              scope.container.msRequestFullscreen();
            scope.container.mozRequestFullScreen &&
              scope.container.mozRequestFullScreen();
            scope.container.webkitRequestFullscreen &&
              scope.container.webkitRequestFullscreen(
                Element.ALLOW_KEYBOARD_INPUT
              );
            isFullscreen = true;
          } else {
            document.exitFullscreen && document.exitFullscreen();
            document.msExitFullscreen && document.msExitFullscreen();
            document.mozCancelFullScreen && document.mozCancelFullScreen();
            document.webkitExitFullscreen && document.webkitExitFullscreen();
            isFullscreen = false;
          }

          this.style.backgroundImage = isFullscreen
            ? 'url("' + DataImage.FullscreenLeave + '")'
            : 'url("' + DataImage.FullscreenEnter + '")';
        }

        function onFullScreenChange(e) {
          if (tapSkipped) {
            isFullscreen = !isFullscreen;

            item.style.backgroundImage = isFullscreen
              ? 'url("' + DataImage.FullscreenLeave + '")'
              : 'url("' + DataImage.FullscreenEnter + '")';
          }

          /**
           * Viewer handler event
           * @type {object}
           * @event Widget#panolens-dual-eye-effect
           * @property {string} method - 'onWindowResize' function call on Viewer
           */
          scope.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "onWindowResize",
            data: false,
          });

          tapSkipped = true;
        }

        document.addEventListener(
          "fullscreenchange",
          onFullScreenChange,
          false
        );
        document.addEventListener(
          "webkitfullscreenchange",
          onFullScreenChange,
          false
        );
        document.addEventListener(
          "mozfullscreenchange",
          onFullScreenChange,
          false
        );
        document.addEventListener(
          "MSFullscreenChange",
          onFullScreenChange,
          false
        );

        item = this.createCustomItem({
          style: {
            backgroundImage: 'url("' + DataImage.FullscreenEnter + '")',
          },

          onTap: onTap,
        });

        // Add fullscreen stlye if not exists
        if (!document.querySelector(stylesheetId)) {
          const sheet = document.createElement("style");
          sheet.id = stylesheetId;
          sheet.innerHTML =
            ":-webkit-full-screen { width: 100% !important; height: 100% !important }";
          document.body.appendChild(sheet);
        }

        return item;
      },

      /**
       * Create video control container
       * @memberOf Widget
       * @instance
       * @return {HTMLSpanElement} - The dom element icon for video control
       */
      createVideoControl: function () {
        const item = document.createElement("span");
        item.style.display = "none";
        item.show = function () {
          item.style.display = "";
        };

        item.hide = function () {
          item.style.display = "none";
          item.controlButton.paused = true;
          item.controlButton.update();
        };

        item.controlButton = this.createVideoControlButton();
        item.seekBar = this.createVideoControlSeekbar();

        item.appendChild(item.controlButton);
        item.appendChild(item.seekBar);

        item.dispose = function () {
          item.removeChild(item.controlButton);
          item.removeChild(item.seekBar);

          item.controlButton.dispose();
          item.controlButton = null;

          item.seekBar.dispose();
          item.seekBar = null;
        };

        this.addEventListener("video-control-show", item.show);
        this.addEventListener("video-control-hide", item.hide);

        return item;
      },

      /**
       * Create video control button
       * @memberOf Widget
       * @instance
       * @return {HTMLSpanElement} - The dom element icon for video control
       * @fires Widget#panolens-viewer-handler
       */
      createVideoControlButton: function () {
        const scope = this;

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          /**
           * Viewer handler event
           * @type {object}
           * @event Widget#panolens-viewer-handler
           * @property {string} method - 'toggleVideoPlay' function call on Viewer
           */
          scope.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "toggleVideoPlay",
            data: !this.paused,
          });

          this.paused = !this.paused;

          item.update();
        }
        const item = this.createCustomItem({
          style: {
            float: "left",
            backgroundImage: 'url("' + DataImage.VideoPlay + '")',
          },

          onTap: onTap,
        });

        item.paused = true;

        item.update = function (paused) {
          this.paused = paused !== undefined ? paused : this.paused;

          this.style.backgroundImage =
            'url("' +
            (this.paused ? DataImage.VideoPlay : DataImage.VideoPause) +
            '")';
        };

        return item;
      },

      /**
       * Create video seekbar
       * @memberOf Widget
       * @instance
       * @return {HTMLSpanElement} - The dom element icon for video seekbar
       * @fires Widget#panolens-viewer-handler
       */
      createVideoControlSeekbar: function () {
        let scope = this,
          item,
          progressElement,
          progressElementControl,
          isDragging = false,
          mouseX,
          percentageNow,
          percentageNext;

        progressElement = document.createElement("div");
        progressElement.style.width = "0%";
        progressElement.style.height = "100%";
        progressElement.style.backgroundColor = "#fff";

        progressElementControl = document.createElement("div");
        progressElementControl.style.float = "right";
        progressElementControl.style.width = "14px";
        progressElementControl.style.height = "14px";
        progressElementControl.style.transform = "translate(7px, -5px)";
        progressElementControl.style.borderRadius = "50%";
        progressElementControl.style.backgroundColor = "#ddd";

        progressElementControl.addEventListener("mousedown", onMouseDown, {
          passive: true,
        });
        progressElementControl.addEventListener("touchstart", onMouseDown, {
          passive: true,
        });

        function onMouseDown(event) {
          event.stopPropagation();

          isDragging = true;

          mouseX =
            event.clientX ||
            (event.changedTouches && event.changedTouches[0].clientX);

          percentageNow = parseInt(progressElement.style.width) / 100;

          addControlListeners();
        }

        function onVideoControlDrag(event) {
          if (isDragging) {
            const clientX =
              event.clientX ||
              (event.changedTouches && event.changedTouches[0].clientX);

            percentageNext = (clientX - mouseX) / item.clientWidth;

            percentageNext = percentageNow + percentageNext;

            percentageNext =
              percentageNext > 1 ? 1 : percentageNext < 0 ? 0 : percentageNext;

            item.setProgress(percentageNext);

            /**
             * Viewer handler event
             * @type {object}
             * @event Widget#panolens-viewer-handler
             * @property {string} method - 'setVideoCurrentTime' function call on Viewer
             * @property {number} data - Percentage of current video. Range from 0.0 to 1.0
             */
            scope.dispatchEvent({
              type: "panolens-viewer-handler",
              method: "setVideoCurrentTime",
              data: percentageNext,
            });
          }
        }

        function onVideoControlStop(event) {
          event.stopPropagation();

          isDragging = false;

          removeControlListeners();
        }

        function addControlListeners() {
          scope.container.addEventListener("mousemove", onVideoControlDrag, {
            passive: true,
          });
          scope.container.addEventListener("mouseup", onVideoControlStop, {
            passive: true,
          });
          scope.container.addEventListener("touchmove", onVideoControlDrag, {
            passive: true,
          });
          scope.container.addEventListener("touchend", onVideoControlStop, {
            passive: true,
          });
        }

        function removeControlListeners() {
          scope.container.removeEventListener(
            "mousemove",
            onVideoControlDrag,
            false
          );
          scope.container.removeEventListener(
            "mouseup",
            onVideoControlStop,
            false
          );
          scope.container.removeEventListener(
            "touchmove",
            onVideoControlDrag,
            false
          );
          scope.container.removeEventListener(
            "touchend",
            onVideoControlStop,
            false
          );
        }

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          if (event.target === progressElementControl) {
            return;
          }

          const percentage =
            event.changedTouches && event.changedTouches.length > 0
              ? (event.changedTouches[0].pageX -
                  event.target.getBoundingClientRect().left) /
                this.clientWidth
              : event.offsetX / this.clientWidth;

          /**
           * Viewer handler event
           * @type {object}
           * @property {string} method - 'setVideoCurrentTime' function call on Viewer
           * @property {number} data - Percentage of current video. Range from 0.0 to 1.0
           */
          scope.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "setVideoCurrentTime",
            data: percentage,
          });

          item.setProgress(event.offsetX / this.clientWidth);
        }
        function onDispose() {
          removeControlListeners();
          progressElement = null;
          progressElementControl = null;
        }

        progressElement.appendChild(progressElementControl);

        item = this.createCustomItem({
          style: {
            float: "left",
            width: "30%",
            height: "4px",
            marginTop: "20px",
            backgroundColor: "rgba(188,188,188,0.8)",
          },

          onTap: onTap,
          onDispose: onDispose,
        });

        item.appendChild(progressElement);

        item.setProgress = function (percentage) {
          progressElement.style.width = percentage * 100 + "%";
        };

        this.addEventListener("video-update", function (event) {
          item.setProgress(event.percentage);
        });

        return item;
      },

      /**
       * Create menu item
       * @param  {string} title - Title to display
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - An anchor tag element
       */
      createMenuItem: function (title) {
        const scope = this;
        const item = document.createElement("a");
        item.textContent = title;
        item.style.display = "block";
        item.style.padding = "10px";
        item.style.textDecoration = "none";
        item.style.cursor = "pointer";
        item.style.pointerEvents = "auto";
        item.style.transition = this.DEFAULT_TRANSITION;

        item.slide = function (right) {
          this.style.transform = "translateX(" + (right ? "" : "-") + "100%)";
        };

        item.unslide = function () {
          this.style.transform = "translateX(0)";
        };

        item.setIcon = function (url) {
          if (this.icon) {
            this.icon.style.backgroundImage = "url(" + url + ")";
          }
        };

        item.setSelectionTitle = function (title) {
          if (this.selection) {
            this.selection.textContent = title;
          }
        };

        item.addSelection = function (name) {
          const selection = document.createElement("span");
          selection.style.fontSize = "13px";
          selection.style.fontWeight = "300";
          selection.style.float = "right";

          this.selection = selection;
          this.setSelectionTitle(name);
          this.appendChild(selection);

          return this;
        };

        item.addIcon = function (
          url = DataImage.ChevronRight,
          left = false,
          flip = false
        ) {
          const element = document.createElement("span");
          element.style.float = left ? "left" : "right";
          element.style.width = "17px";
          element.style.height = "17px";
          element.style["margin" + (left ? "Right" : "Left")] = "12px";
          element.style.backgroundSize = "cover";

          if (flip) {
            element.style.transform = "rotateZ(180deg)";
          }

          this.icon = element;
          this.setIcon(url);
          this.appendChild(element);

          return this;
        };

        item.addSubMenu = function (title, items) {
          this.subMenu = scope.createSubMenu(title, items);

          return this;
        };

        item.addEventListener(
          "mouseenter",
          function () {
            this.style.backgroundColor = "#e0e0e0";
          },
          false
        );

        item.addEventListener(
          "mouseleave",
          function () {
            this.style.backgroundColor = "#fafafa";
          },
          false
        );

        return item;
      },

      /**
       * Create menu item header
       * @param  {string} title - Title to display
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - An anchor tag element
       */
      createMenuItemHeader: function (title) {
        const header = this.createMenuItem(title);

        header.style.borderBottom = "1px solid #333";
        header.style.paddingBottom = "15px";

        return header;
      },

      /**
       * Create main menu
       * @param  {array} menus - Menu array list
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - A span element
       */
      createMainMenu: function (menus) {
        let scope = this,
          menu = this.createMenu();

        menu._width = 200;
        menu.changeSize(menu._width);

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          let mainMenu = scope.mainMenu,
            subMenu = this.subMenu;

          function onNextTick() {
            mainMenu.changeSize(subMenu.clientWidth);
            subMenu.show();
            subMenu.unslideAll();
          }

          mainMenu.hide();
          mainMenu.slideAll();
          mainMenu.parentElement.appendChild(subMenu);

          scope.activeMainItem = this;
          scope.activeSubMenu = subMenu;

          window.requestAnimationFrame(onNextTick);
        }
        for (var i = 0; i < menus.length; i++) {
          var item = menu.addItem(menus[i].title);

          item.style.paddingLeft = "20px";

          item
            .addIcon()
            .addEventListener(
              scope.TOUCH_ENABLED ? "touchend" : "click",
              onTap,
              false
            );

          if (menus[i].subMenu && menus[i].subMenu.length > 0) {
            var title = menus[i].subMenu[0].title;

            item
              .addSelection(title)
              .addSubMenu(menus[i].title, menus[i].subMenu);
          }
        }

        return menu;
      },

      /**
       * Create sub menu
       * @param {string} title - Sub menu title
       * @param {array} items - Item array list
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - A span element
       */
      createSubMenu: function (title, items) {
        let scope = this,
          menu,
          subMenu = this.createMenu();

        subMenu.items = items;
        subMenu.activeItem;

        function onTap(event) {
          event.preventDefault();
          event.stopPropagation();

          menu = scope.mainMenu;
          menu.changeSize(menu._width);
          menu.unslideAll();
          menu.show();
          subMenu.slideAll(true);
          subMenu.hide();

          if (this.type !== "header") {
            subMenu.setActiveItem(this);
            scope.activeMainItem.setSelectionTitle(this.textContent);

            this.handler && this.handler();
          }
        }

        subMenu
          .addHeader(title)
          .addIcon(undefined, true, true)
          .addEventListener(
            scope.TOUCH_ENABLED ? "touchend" : "click",
            onTap,
            false
          );

        for (let i = 0; i < items.length; i++) {
          const item = subMenu.addItem(items[i].title);

          item.style.fontWeight = 300;
          item.handler = items[i].handler;
          item.addIcon(" ", true);
          item.addEventListener(
            scope.TOUCH_ENABLED ? "touchend" : "click",
            onTap,
            false
          );

          if (!subMenu.activeItem) {
            subMenu.setActiveItem(item);
          }
        }

        subMenu.slideAll(true);

        return subMenu;
      },

      /**
       * Create general menu
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - A span element
       */
      createMenu: function () {
        const scope = this;
        const menu = document.createElement("span");
        const style = menu.style;

        style.padding = "5px 0";
        style.position = "fixed";
        style.bottom = "100%";
        style.right = "14px";
        style.backgroundColor = "#fafafa";
        style.fontFamily = "Helvetica Neue";
        style.fontSize = "14px";
        style.visibility = "hidden";
        style.opacity = 0;
        style.boxShadow = "0 0 12pt rgba(0,0,0,0.25)";
        style.borderRadius = "2px";
        style.overflow = "hidden";
        style.willChange = "width, height, opacity";
        style.pointerEvents = "auto";
        style.transition = this.DEFAULT_TRANSITION;

        menu.visible = false;

        menu.changeSize = function (width, height) {
          if (width) {
            this.style.width = width + "px";
          }

          if (height) {
            this.style.height = height + "px";
          }
        };

        menu.show = function () {
          this.style.opacity = 1;
          this.style.visibility = "visible";
          this.visible = true;
        };

        menu.hide = function () {
          this.style.opacity = 0;
          this.style.visibility = "hidden";
          this.visible = false;
        };

        menu.toggle = function () {
          if (this.visible) {
            this.hide();
          } else {
            this.show();
          }
        };

        menu.slideAll = function (right) {
          for (let i = 0; i < menu.children.length; i++) {
            if (menu.children[i].slide) {
              menu.children[i].slide(right);
            }
          }
        };

        menu.unslideAll = function () {
          for (let i = 0; i < menu.children.length; i++) {
            if (menu.children[i].unslide) {
              menu.children[i].unslide();
            }
          }
        };

        menu.addHeader = function (title) {
          const header = scope.createMenuItemHeader(title);
          header.type = "header";

          this.appendChild(header);

          return header;
        };

        menu.addItem = function (title) {
          const item = scope.createMenuItem(title);
          item.type = "item";

          this.appendChild(item);

          return item;
        };

        menu.setActiveItem = function (item) {
          if (this.activeItem) {
            this.activeItem.setIcon(" ");
          }

          item.setIcon(DataImage.Check);

          this.activeItem = item;
        };

        menu.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, true);
        menu.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, true);
        menu.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, true);

        return menu;
      },

      /**
       * Create custom item element
       * @memberOf Widget
       * @instance
       * @return {HTMLSpanElement} - The dom element icon
       */
      createCustomItem: function (options = {}) {
        const scope = this;
        const item = options.element || document.createElement("span");

        item.style.cursor = "pointer";
        item.style.float = "right";
        item.style.width = "44px";
        item.style.height = "100%";
        item.style.backgroundSize = "60%";
        item.style.backgroundRepeat = "no-repeat";
        item.style.backgroundPosition = "center";
        item.style.webkitUserSelect = item.style.MozUserSelect = item.style.userSelect =
          "none";
        item.style.position = "relative";
        item.style.pointerEvents = "auto";

        // White glow on icon
        item.addEventListener(
          scope.TOUCH_ENABLED ? "touchstart" : "mouseenter",
          function () {
            item.style.filter = item.style.webkitFilter =
              "drop-shadow(0 0 5px rgba(255,255,255,1))";
          },
          { passive: true }
        );
        item.addEventListener(
          scope.TOUCH_ENABLED ? "touchend" : "mouseleave",
          function () {
            item.style.filter = item.style.webkitFilter = "";
          },
          { passive: true }
        );

        this.mergeStyleOptions(item, options.style);

        if (options.onTap) {
          item.addEventListener(
            scope.TOUCH_ENABLED ? "touchend" : "click",
            options.onTap,
            false
          );
        }

        item.dispose = function () {
          item.removeEventListener(
            scope.TOUCH_ENABLED ? "touchend" : "click",
            options.onTap,
            false
          );

          options.onDispose && options.onDispose();
        };

        return item;
      },

      /*
			Author: silqwer
			Compass functions
		*/

      createCompass: function () {
        var scope = this;
        var item = this.createCustomItem({
          style: {
            float: "left",
            cursor: "default",
          },
        });

        //item.background = this.createCompassBackground();
        //item.innerDot = this.createCompassInnerDot();
        item.innerView = this.createCompassInnerView();
        //item.outerRing = this.createCompassOuterRing();

        //item.appendChild(item.background);
        //item.appendChild(item.innerDot);
        item.appendChild(item.innerView);
        //item.appendChild(item.outerRing);

        return item;
      },

      createCompassBackground: function () {
        var item;

        item = this.createCustomItem({
          style: {
            float: "left",
            backgroundImage: 'url("' + DataImage.CompassBackground + '")',
            cursor: "default",
            position: "absolte",
          },
        });

        return item;
      },

      createCompassInnerDot: function () {
        var item;

        item = this.createCustomItem({
          style: {
            float: "left",
            backgroundImage: 'url("' + DataImage.CompassInnerDot + '")',
            cursor: "default",
            position: "absolte",
          },
        });

        return item;
      },

      createCompassInnerView: function () {
        var item;
        var scope = this;

        item = this.createCustomItem({
          style: {
            float: "left",
            backgroundImage: 'url("' + DataImage.CompassInnerView + '")',
            cursor: "default",
            position: "absolte",
            bottom: "30px",
            right: "-10px",
			width: "80px",
			height: "80px",
          },
        });

        scope.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "onRotationChange",
          data: item,
        });

        return item;
      },

      createCompassOuterRing: function () {
        var item;

        item = this.createCustomItem({
          style: {
            float: "left",
            backgroundImage: 'url("' + DataImage.CompassOuterRing + '")',
            cursor: "default",
            position: "absolte",
          },
        });

        return item;
      },

      /**
       * Merge item css style
       * @param  {HTMLElement} element - The element to be merged with style
       * @param  {object} options - The style options
       * @memberOf Widget
       * @instance
       * @return {HTMLElement} - The same element with merged styles
       */
      mergeStyleOptions: function (element, options = {}) {
        for (let property in options) {
          if (options.hasOwnProperty(property)) {
            element.style[property] = options[property];
          }
        }

        return element;
      },

      /**
       * Dispose widgets by detaching dom elements from container
       * @memberOf Widget
       * @instance
       */
      dispose: function () {
        if (this.barElement) {
          this.container.removeChild(this.barElement);
          this.barElement.dispose();
          this.barElement = null;
        }
      },
    }
  );

  /**
   * @classdesc Base Panorama
   * @constructor
   * @param {THREE.Geometry} geometry - The geometry for this panorama
   * @param {THREE.Material} material - The material for this panorama
   */
  function Panorama(geometry, material) {
    THREE.Mesh.call(this, geometry, material);

    this.type = "panorama";

    this.ImageQualityLow = 1;
    this.ImageQualityFair = 2;
    this.ImageQualityMedium = 3;
    this.ImageQualityHigh = 4;
    this.ImageQualitySuperHigh = 5;

    this.animationDuration = 1000;

    this.defaultInfospotSize = 350;

    this.container = undefined;

    this.loaded = false;

    this.linkedSpots = [];

    this.isInfospotVisible = false;

    this.linkingImageURL = undefined;
    this.linkingImageScale = undefined;

    this.material.side = THREE.BackSide;
    this.material.opacity = 0;

    this.scale.x *= -1;
    this.renderOrder = -1;

    this.active = false;

    this.infospotAnimation = new Tween.Tween(this).to(
      {},
      this.animationDuration / 2
    );

    this.addEventListener("load", this.fadeIn.bind(this));
    this.addEventListener("panolens-container", this.setContainer.bind(this));
    this.addEventListener("click", this.onClick.bind(this));

    this.setupTransitions();
  }

  Panorama.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
    constructor: Panorama,

    /**
     * Adding an object
     * To counter the scale.x = -1, it will automatically add an
     * empty object with inverted scale on x
     * @memberOf Panorama
     * @instance
     * @param {THREE.Object3D} object - The object to be added
     */
    add: function (object) {
      let invertedObject;

      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }

        return this;
      }

      // In case of infospots
      if (object instanceof Infospot) {
        invertedObject = object;

        if (object.dispatchEvent) {
          this.container &&
            object.dispatchEvent({
              type: "panolens-container",
              container: this.container,
            });

          object.dispatchEvent({
            type: "panolens-infospot-focus",
            method: function (vector, duration, easing) {
              /**
               * Infospot focus handler event
               * @type {object}
               * @event Panorama#panolens-viewer-handler
               * @property {string} method - Viewer function name
               * @property {*} data - The argument to be passed into the method
               */
              this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "tweenControlCenter",
                data: [vector, duration, easing],
              });
            }.bind(this),
          });
        }
      } else {
        // Counter scale.x = -1 effect
        invertedObject = new THREE.Object3D();
        invertedObject.scale.x = -1;
        invertedObject.scalePlaceHolder = true;
        invertedObject.add(object);
      }

      THREE.Object3D.prototype.add.call(this, invertedObject);
    },

    load: function () {
      this.onLoad();
    },

    /**
     * Click event handler
     * @param  {object} event - Click event
     * @memberOf Panorama
     * @instance
     * @fires Infospot#dismiss
     */
    onClick: function (event) {
      if (event.intersects && event.intersects.length === 0) {
        this.traverse(function (object) {
          /**
           * Dimiss event
           * @type {object}
           * @event Infospot#dismiss
           */
          object.dispatchEvent({ type: "dismiss" });
        });
      }
    },

    /**
     * Set container of this panorama
     * @param {HTMLElement|object} data - Data with container information
     * @memberOf Panorama
     * @instance
     * @fires Infospot#panolens-container
     */
    setContainer: function (data) {
      let container;

      if (data instanceof HTMLElement) {
        container = data;
      } else if (data && data.container) {
        container = data.container;
      }

      if (container) {
        this.children.forEach(function (child) {
          if (child instanceof Infospot && child.dispatchEvent) {
            /**
             * Set container event
             * @type {object}
             * @event Infospot#panolens-container
             * @property {HTMLElement} container - The container of this panorama
             */
            child.dispatchEvent({
              type: "panolens-container",
              container: container,
            });
          }
        });

        this.container = container;
      }
    },

    /**
     * This will be called when panorama is loaded
     * @memberOf Panorama
     * @instance
     * @fires Panorama#load
     */
    onLoad: function () {
      this.loaded = true;

      /**
       * Load panorama event
       * @type {object}
       * @event Panorama#load
       */
      this.dispatchEvent({ type: "load" });
    },

    /**
     * This will be called when panorama is in progress
     * @memberOf Panorama
     * @instance
     * @fires Panorama#progress
     */
    onProgress: function (progress) {
      /**
       * Loading panorama progress event
       * @type {object}
       * @event Panorama#progress
       * @property {object} progress - The progress object containing loaded and total amount
       */
      this.dispatchEvent({ type: "progress", progress: progress });
    },

    /**
     * This will be called when panorama loading has error
     * @memberOf Panorama
     * @instance
     * @fires Panorama#error
     */
    onError: function () {
      /**
       * Loading panorama error event
       * @type {object}
       * @event Panorama#error
       */
      this.dispatchEvent({ type: "error" });
    },

    /**
     * Get zoom level based on window width
     * @memberOf Panorama
     * @instance
     * @return {number} zoom level indicating image quality
     */
    getZoomLevel: function () {
      let zoomLevel;

      if (window.innerWidth <= 800) {
        zoomLevel = this.ImageQualityFair;
      } else if (window.innerWidth > 800 && window.innerWidth <= 1280) {
        zoomLevel = this.ImageQualityMedium;
      } else if (window.innerWidth > 1280 && window.innerWidth <= 1920) {
        zoomLevel = this.ImageQualityHigh;
      } else if (window.innerWidth > 1920) {
        zoomLevel = this.ImageQualitySuperHigh;
      } else {
        zoomLevel = this.ImageQualityLow;
      }

      return zoomLevel;
    },

    /**
     * Update texture of a panorama
     * @memberOf Panorama
     * @instance
     * @param {THREE.Texture} texture - Texture to be updated
     */
    updateTexture: function (texture) {
      this.material.map = texture;
      this.material.needsUpdate = true;
    },

    /**
     * Toggle visibility of infospots in this panorama
     * @param  {boolean} isVisible - Visibility of infospots
     * @param  {number} delay - Delay in milliseconds to change visibility
     * @memberOf Panorama
     * @instance
     * @fires Panorama#infospot-animation-complete
     */
    toggleInfospotVisibility: function (isVisible, delay) {
      delay = delay !== undefined ? delay : 0;

      const visible =
        isVisible !== undefined
          ? isVisible
          : this.isInfospotVisible
          ? false
          : true;

      this.traverse(function (object) {
        if (object instanceof Infospot) {
          visible ? object.show(delay) : object.hide(delay);
        }
      });

      this.isInfospotVisible = visible;

      // Animation complete event
      this.infospotAnimation
        .onComplete(
          function () {
            /**
             * Complete toggling infospot visibility
             * @event Panorama#infospot-animation-complete
             * @type {object}
             */
            this.dispatchEvent({
              type: "infospot-animation-complete",
              visible: visible,
            });
          }.bind(this)
        )
        .delay(delay)
        .start();
    },

    /**
     * Set image of this panorama's linking infospot
     * @memberOf Panorama
     * @instance
     * @param {string} url   - Url to the image asset
     * @param {number} scale - Scale factor of the infospot
     */
    setLinkingImage: function (url, scale) {
      this.linkingImageURL = url;
      this.linkingImageScale = scale;
    },

    /**
     * Link one-way panorama
     * @param  {Panorama} pano  - The panorama to be linked to
     * @param  {THREE.Vector3} position - The position of infospot which navigates to the pano
     * @param  {number} [imageScale=300] - Image scale of linked infospot
     * @param  {string} [imageSrc=DataImage.Arrow] - The image source of linked infospot
     * @memberOf Panorama
     * @instance
     */
    link: function (pano, position, imageScale, imageSrc) {
      let scale, img;

      this.visible = true;

      if (!position) {
        console.warn("Please specify infospot position for linking");

        return;
      }

      // Infospot scale
      if (imageScale !== undefined) {
        scale = imageScale;
      } else if (pano.linkingImageScale !== undefined) {
        scale = pano.linkingImageScale;
      } else {
        scale = 300;
      }

      // Infospot image
      if (imageSrc) {
        img = imageSrc;
      } else if (pano.linkingImageURL) {
        img = pano.linkingImageURL;
      } else {
        img = DataImage.Arrow;
      }

      // Creates a new infospot
      const spot = new Infospot(scale, img);
      spot.position.copy(position);
      spot.toPanorama = pano;
      spot.addEventListener(
        "click",
        function () {
          /**
           * Viewer handler event
           * @type {object}
           * @event Panorama#panolens-viewer-handler
           * @property {string} method - Viewer function name
           * @property {*} data - The argument to be passed into the method
           */
          this.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "setPanorama",
            data: pano,
          });
        }.bind(this)
      );

      this.linkedSpots.push(spot);

      this.add(spot);

      this.visible = false;
    },

    reset: function () {
      this.children.length = 0;
    },

    setupTransitions: function () {
      this.fadeInAnimation = new Tween.Tween(this.material)
        .easing(Tween.Easing.Quartic.Out)
        .onStart(
          function () {
            this.visible = true;
            // this.material.visible = true;

            /**
             * Enter panorama fade in start event
             * @event Panorama#enter-fade-start
             * @type {object}
             */
            this.dispatchEvent({ type: "enter-fade-start" });
          }.bind(this)
        );

      this.fadeOutAnimation = new Tween.Tween(this.material)
        .easing(Tween.Easing.Quartic.Out)
        .onComplete(
          function () {
            this.visible = false;
            // this.material.visible = true;

            /**
             * Leave panorama complete event
             * @event Panorama#leave-complete
             * @type {object}
             */
            this.dispatchEvent({ type: "leave-complete" });
          }.bind(this)
        );

      this.enterTransition = new Tween.Tween(this)
        .easing(Tween.Easing.Quartic.Out)
        .onComplete(
          function () {
            /**
             * Enter panorama and animation complete event
             * @event Panorama#enter-animation-complete
             * @type {object}
             */
            this.dispatchEvent({ type: "enter-animation-complete" });
          }.bind(this)
        )
        .start();

      this.leaveTransition = new Tween.Tween(this).easing(
        Tween.Easing.Quartic.Out
      );
    },

    onFadeAnimationUpdate: function () {
      const alpha = this.material.opacity;
      const { uniforms } = this.material;

      if (uniforms && uniforms.opacity) {
        uniforms.opacity.value = alpha;
      }
    },

    /**
     * Start fading in animation
     * @memberOf Panorama
     * @instance
     * @fires Panorama#enter-fade-complete
     */
    fadeIn: function (duration) {
      duration = duration >= 0 ? duration : this.animationDuration;

      this.fadeOutAnimation.stop();
      this.fadeInAnimation
        .to({ opacity: 1 }, duration)
        .onUpdate(this.onFadeAnimationUpdate.bind(this))
        .onComplete(
          function () {
            this.toggleInfospotVisibility(true, duration / 2);

            /**
             * Enter panorama fade complete event
             * @event Panorama#enter-fade-complete
             * @type {object}
             */
            this.dispatchEvent({ type: "enter-fade-complete" });
          }.bind(this)
        )
        .start();
    },

    /**
     * Start fading out animation
     * @memberOf Panorama
     * @instance
     */
    fadeOut: function (duration) {
      duration = duration >= 0 ? duration : this.animationDuration;

      this.fadeInAnimation.stop();
      this.fadeOutAnimation
        .to({ opacity: 0 }, duration)
        .onUpdate(this.onFadeAnimationUpdate.bind(this))
        .start();
    },

    /**
     * This will be called when entering a panorama
     * @memberOf Panorama
     * @instance
     * @fires Panorama#enter
     * @fires Panorama#enter-animation-start
     */
    onEnter: function () {
      const duration = this.animationDuration;

      this.leaveTransition.stop();
      this.enterTransition
        .to({}, duration)
        .onStart(
          function () {
            /**
             * Enter panorama and animation starting event
             * @event Panorama#enter-animation-start
             * @type {object}
             */
            this.dispatchEvent({ type: "enter-animation-start" });

            if (this.loaded) {
              this.fadeIn(duration);
            } else {
              this.load();
            }
          }.bind(this)
        )
        .start();

      /**
       * Enter panorama event
       * @event Panorama#enter
       * @type {object}
       */
      this.dispatchEvent({ type: "enter" });

      this.children.forEach((child) => {
        child.dispatchEvent({ type: "panorama-enter" });
      });

      this.active = true;
    },

    /**
     * This will be called when leaving a panorama
     * @memberOf Panorama
     * @instance
     * @fires Panorama#leave
     */
    onLeave: function () {
      const duration = this.animationDuration;

      this.enterTransition.stop();
      this.leaveTransition
        .to({}, duration)
        .onStart(
          function () {
            /**
             * Leave panorama and animation starting event
             * @event Panorama#leave-animation-start
             * @type {object}
             */
            this.dispatchEvent({ type: "leave-animation-start" });

            this.fadeOut(duration);
            this.toggleInfospotVisibility(false);
          }.bind(this)
        )
        .start();

      /**
       * Leave panorama event
       * @event Panorama#leave
       * @type {object}
       */
      this.dispatchEvent({ type: "leave" });

      this.children.forEach((child) => {
        child.dispatchEvent({ type: "panorama-leave" });
      });

      this.active = false;
    },

    /**
     * Dispose panorama
     * @memberOf Panorama
     * @instance
     */
    dispose: function () {
      /**
       * On panorama dispose handler
       * @type {object}
       * @event Panorama#panolens-viewer-handler
       * @property {string} method - Viewer function name
       * @property {*} data - The argument to be passed into the method
       */
      this.dispatchEvent({
        type: "panolens-viewer-handler",
        method: "onPanoramaDispose",
        data: this,
      });

      // recursive disposal on 3d objects
      function recursiveDispose(object) {
        for (var i = object.children.length - 1; i >= 0; i--) {
          recursiveDispose(object.children[i]);
          object.remove(object.children[i]);
        }

        if (object instanceof Infospot) {
          object.dispose();
        }

        object.geometry && object.geometry.dispose();
        object.material && object.material.dispose();
      }

      recursiveDispose(this);

      if (this.parent) {
        this.parent.remove(this);
      }
    },
  });

  /**
   * @classdesc Equirectangular based image panorama
   * @constructor
   * @param {string} image - Image url or HTMLImageElement
   */
  function ImagePanorama(image, _geometry, _material) {
    const radius = 5000;
    const geometry =
      _geometry || new THREE.SphereBufferGeometry(radius, 60, 40);
    const material =
      _material ||
      new THREE.MeshBasicMaterial({ opacity: 0, transparent: true });

    Panorama.call(this, geometry, material);

    this.src = image;
    this.radius = radius;
  }

  ImagePanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
    constructor: ImagePanorama,

    /**
     * Load image asset
     * @param  {*} src - Url or image element
     * @memberOf ImagePanorama
     * @instance
     */
    load: function (src) {
      src = src || this.src;

      if (!src) {
        console.warn("Image source undefined");

        return;
      } else if (typeof src === "string") {
        TextureLoader.load(
          src,
          this.onLoad.bind(this),
          this.onProgress.bind(this),
          this.onError.bind(this)
        );
      } else if (src instanceof HTMLImageElement) {
        this.onLoad(new THREE.Texture(src));
      }
    },

    /**
     * This will be called when image is loaded
     * @param  {THREE.Texture} texture - Texture to be updated
     * @memberOf ImagePanorama
     * @instance
     */
    onLoad: function (texture) {
      texture.minFilter = texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      this.updateTexture(texture);

      requestAnimationFrame(Panorama.prototype.onLoad.bind(this));
    },

    /**
     * Reset
     * @memberOf ImagePanorama
     * @instance
     */
    reset: function () {
      Panorama.prototype.reset.call(this);
    },

    /**
     * Dispose
     * @memberOf ImagePanorama
     * @instance
     */
    dispose: function () {
      // Release cached image
      THREE.Cache.remove(this.src);

      this.material.map && this.material.map.dispose();

      Panorama.prototype.dispose.call(this);
    },
  });

  /**
   * @classdesc Empty panorama
   * @constructor
   */
  function EmptyPanorama() {
    const geometry = new THREE.BufferGeometry();
    const material = new THREE.MeshBasicMaterial({
      color: 0x000000,
      opacity: 0,
      transparent: true,
    });

    geometry.addAttribute(
      "position",
      new THREE.BufferAttribute(new Float32Array(), 1)
    );

    Panorama.call(this, geometry, material);
  }

  EmptyPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
    constructor: EmptyPanorama,
  });

  /**
   * @classdesc Cubemap-based panorama
   * @constructor
   * @param {array} images - Array of 6 urls to images, one for each side of the CubeTexture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z
   */
  function CubePanorama(images = []) {
    const edgeLength = 10000;
    const shader = JSON.parse(JSON.stringify(THREE.ShaderLib["cube"]));
    const geometry = new THREE.BoxBufferGeometry(
      edgeLength,
      edgeLength,
      edgeLength
    );
    const material = new THREE.ShaderMaterial({
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      side: THREE.BackSide,
      transparent: true,
    });

    Panorama.call(this, geometry, material);

    this.images = images;
    this.edgeLength = edgeLength;
    this.material.uniforms.opacity.value = 0;
  }

  CubePanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
    constructor: CubePanorama,

    /**
     * Load 6 images and bind listeners
     * @memberOf CubePanorama
     * @instance
     */
    load: function () {
      CubeTextureLoader.load(
        this.images,

        this.onLoad.bind(this),
        this.onProgress.bind(this),
        this.onError.bind(this)
      );
    },

    /**
     * This will be called when 6 textures are ready
     * @param  {THREE.CubeTexture} texture - Cube texture
     * @memberOf CubePanorama
     * @instance
     */
    onLoad: function (texture) {
      this.material.uniforms["tCube"].value = texture;

      Panorama.prototype.onLoad.call(this);
    },

    /**
     * Dispose
     * @memberOf CubePanorama
     * @instance
     */
    dispose: function () {
      this.images.forEach((image) => {
        THREE.Cache.remove(image);
      });

      this.material.uniforms["tCube"] &&
        this.material.uniforms["tCube"].value.dispose();

      Panorama.prototype.dispose.call(this);
    },
  });

  /**
   * @classdesc Basic panorama with 6 pre-defined grid images
   * @constructor
   */
  function BasicPanorama() {
    const images = [];

    for (let i = 0; i < 6; i++) {
      images.push(DataImage.WhiteTile);
    }

    CubePanorama.call(this, images);
  }

  BasicPanorama.prototype = Object.assign(
    Object.create(CubePanorama.prototype),
    {
      constructor: BasicPanorama,
    }
  );

  /**
   * @classdesc Video Panorama
   * @constructor
   * @param {string} src - Equirectangular video url
   * @param {object} [options] - Option for video settings
   * @param {HTMLElement} [options.videoElement] - HTML5 video element contains the video
   * @param {boolean} [options.loop=true] - Specify if the video should loop in the end
   * @param {boolean} [options.muted=true] - Mute the video or not. Need to be true in order to autoplay on some browsers
   * @param {boolean} [options.autoplay=false] - Specify if the video should auto play
   * @param {boolean} [options.playsinline=true] - Specify if video should play inline for iOS. If you want it to auto play inline, set both autoplay and muted options to true
   * @param {string} [options.crossOrigin="anonymous"] - Sets the cross-origin attribute for the video, which allows for cross-origin videos in some browsers (Firefox, Chrome). Set to either "anonymous" or "use-credentials".
   * @param {number} [radius=5000] - The minimum radius for this panoram
   */
  function VideoPanorama(src, options = {}) {
    const radius = 5000;
    const geometry = new THREE.SphereBufferGeometry(radius, 60, 40);
    const material = new THREE.MeshBasicMaterial({
      opacity: 0,
      transparent: true,
    });

    Panorama.call(this, geometry, material);

    this.src = src;

    this.options = {
      videoElement: document.createElement("video"),
      loop: true,
      muted: true,
      autoplay: false,
      playsinline: true,
      crossOrigin: "anonymous",
    };

    Object.assign(this.options, options);

    this.videoElement = this.options.videoElement;
    this.videoProgress = 0;
    this.radius = radius;

    this.addEventListener("leave", this.pauseVideo.bind(this));
    this.addEventListener(
      "enter-fade-start",
      this.resumeVideoProgress.bind(this)
    );
    this.addEventListener("video-toggle", this.toggleVideo.bind(this));
    this.addEventListener("video-time", this.setVideoCurrentTime.bind(this));
  }
  VideoPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
    constructor: VideoPanorama,

    isMobile: function () {
      let check = false;
      (function (a) {
        if (
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
            a
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            a.substr(0, 4)
          )
        )
          check = true;
      })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    },

    /**
     * Load video panorama
     * @memberOf VideoPanorama
     * @instance
     * @fires  Panorama#panolens-viewer-handler
     */
    load: function () {
      const { muted, loop, autoplay, playsinline, crossOrigin } = this.options;
      const video = this.videoElement;
      const material = this.material;
      const onProgress = this.onProgress.bind(this);
      const onLoad = this.onLoad.bind(this);

      video.loop = loop;
      video.autoplay = autoplay;
      video.playsinline = playsinline;
      video.crossOrigin = crossOrigin;
      video.muted = muted;

      if (playsinline) {
        video.setAttribute("playsinline", "");
        video.setAttribute("webkit-playsinline", "");
      }

      const onloadeddata = function (event) {
        this.setVideoTexture(video);

        if (autoplay) {
          /**
           * Viewer handler event
           * @type {object}
           * @property {string} method - 'updateVideoPlayButton'
           * @property {boolean} data - Pause video or not
           */
          this.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "updateVideoPlayButton",
            data: false,
          });
        }

        // For mobile silent autoplay
        if (this.isMobile()) {
          video.pause();

          if (autoplay && muted) {
            /**
             * Viewer handler event
             * @type {object}
             * @property {string} method - 'updateVideoPlayButton'
             * @property {boolean} data - Pause video or not
             */
            this.dispatchEvent({
              type: "panolens-viewer-handler",
              method: "updateVideoPlayButton",
              data: false,
            });
          } else {
            /**
             * Viewer handler event
             * @type {object}
             * @property {string} method - 'updateVideoPlayButton'
             * @property {boolean} data - Pause video or not
             */
            this.dispatchEvent({
              type: "panolens-viewer-handler",
              method: "updateVideoPlayButton",
              data: true,
            });
          }
        }

        const loaded = () => {
          // Fix for threejs r89 delayed update
          material.map.needsUpdate = true;

          onProgress({ loaded: 1, total: 1 });
          onLoad();
        };

        requestAnimationFrame(loaded);
      };

      /**
       * Ready state of the audio/video element
       * 0 = HAVE_NOTHING - no information whether or not the audio/video is ready
       * 1 = HAVE_METADATA - metadata for the audio/video is ready
       * 2 = HAVE_CURRENT_DATA - data for the current playback position is available, but not enough data to play next frame/millisecond
       * 3 = HAVE_FUTURE_DATA - data for the current and at least the next frame is available
       * 4 = HAVE_ENOUGH_DATA - enough data available to start playing
       */
      if (video.readyState > 2) {
        onloadeddata.call(this);
      } else {
        if (!video.querySelectorAll("source").length || !video.src) {
          video.src = this.src;
        }

        video.load();
      }

      video.addEventListener("loadeddata", onloadeddata.bind(this));

      video.addEventListener(
        "timeupdate",
        function (event) {
          this.videoProgress =
            video.duration >= 0 ? video.currentTime / video.duration : 0;

          /**
           * Viewer handler event
           * @type {object}
           * @property {string} method - 'onVideoUpdate'
           * @property {number} data - The percentage of video progress. Range from 0.0 to 1.0
           */
          this.dispatchEvent({
            type: "panolens-viewer-handler",
            method: "onVideoUpdate",
            data: this.videoProgress,
          });
        }.bind(this)
      );

      video.addEventListener(
        "ended",
        function () {
          if (!loop) {
            this.resetVideo();
            this.dispatchEvent({
              type: "panolens-viewer-handler",
              method: "updateVideoPlayButton",
              data: true,
            });
          }
        }.bind(this),
        false
      );
    },

    /**
     * Set video texture
     * @memberOf VideoPanorama
     * @instance
     * @param {HTMLVideoElement} video  - The html5 video element
     * @fires Panorama#panolens-viewer-handler
     */
    setVideoTexture: function (video) {
      if (!video) return;

      const videoTexture = new THREE.VideoTexture(video);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBFormat;

      this.updateTexture(videoTexture);
    },

    /**
     * Reset
     * @memberOf VideoPanorama
     * @instance
     */
    reset: function () {
      this.videoElement = undefined;

      Panorama.prototype.reset.call(this);
    },

    /**
     * Check if video is paused
     * @memberOf VideoPanorama
     * @instance
     * @return {boolean} - is video paused or not
     */
    isVideoPaused: function () {
      return this.videoElement.paused;
    },

    /**
     * Toggle video to play or pause
     * @memberOf VideoPanorama
     * @instance
     */
    toggleVideo: function () {
      const video = this.videoElement;

      if (!video) {
        return;
      }

      video[video.paused ? "play" : "pause"]();
    },

    /**
     * Set video currentTime
     * @memberOf VideoPanorama
     * @instance
     * @param {object} event - Event contains percentage. Range from 0.0 to 1.0
     */
    setVideoCurrentTime: function ({ percentage }) {
      const video = this.videoElement;

      if (video && !Number.isNaN(percentage) && percentage !== 1) {
        video.currentTime = video.duration * percentage;

        this.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "onVideoUpdate",
          data: percentage,
        });
      }
    },

    /**
     * Play video
     * @memberOf VideoPanorama
     * @instance
     * @fires VideoPanorama#play
     */
    playVideo: function () {
      const video = this.videoElement;

      if (video && video.paused) {
        video.play();
      }

      /**
       * Play event
       * @type {object}
       * @event VideoPanorama#play
       *
       */
      this.dispatchEvent({ type: "play" });
    },

    /**
     * Pause video
     * @memberOf VideoPanorama
     * @instance
     * @fires VideoPanorama#pause
     */
    pauseVideo: function () {
      const video = this.videoElement;

      if (video && !video.paused) {
        video.pause();
      }

      /**
       * Pause event
       * @type {object}
       * @event VideoPanorama#pause
       *
       */
      this.dispatchEvent({ type: "pause" });
    },

    /**
     * Resume video
     * @memberOf VideoPanorama
     * @instance
     */
    resumeVideoProgress: function () {
      const video = this.videoElement;

      if (video.readyState >= 4 && video.autoplay && !this.isMobile()) {
        this.playVideo();

        /**
         * Viewer handler event
         * @type {object}
         * @property {string} method - 'updateVideoPlayButton'
         * @property {boolean} data - Pause video or not
         */
        this.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "updateVideoPlayButton",
          data: false,
        });
      } else {
        this.pauseVideo();

        /**
         * Viewer handler event
         * @type {object}
         * @property {string} method - 'updateVideoPlayButton'
         * @property {boolean} data - Pause video or not
         */
        this.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "updateVideoPlayButton",
          data: true,
        });
      }

      this.setVideoCurrentTime({ percentage: this.videoProgress });
    },

    /**
     * Reset video at stating point
     * @memberOf VideoPanorama
     * @instance
     */
    resetVideo: function () {
      const video = this.videoElement;

      if (video) {
        this.setVideoCurrentTime({ percentage: 0 });
      }
    },

    /**
     * Check if video is muted
     * @memberOf VideoPanorama
     * @instance
     * @return {boolean} - is video muted or not
     */
    isVideoMuted: function () {
      return this.videoElement.muted;
    },

    /**
     * Mute video
     * @memberOf VideoPanorama
     * @instance
     */
    muteVideo: function () {
      const video = this.videoElement;

      if (video && !video.muted) {
        video.muted = true;
      }

      this.dispatchEvent({ type: "volumechange" });
    },

    /**
     * Unmute video
     * @memberOf VideoPanorama
     * @instance
     */
    unmuteVideo: function () {
      const video = this.videoElement;

      if (this.videoElement && this.isVideoMuted()) {
        this.videoElement.muted = false;
      }

      this.dispatchEvent({ type: "volumechange" });
    },

    /**
     * Returns the video element
     * @memberOf VideoPanorama
     * @instance
     * @returns {HTMLElement}
     */
    getVideoElement: function () {
      return this.videoElement;
    },

    /**
     * Dispose video panorama
     * @memberOf VideoPanorama
     * @instance
     */
    dispose: function () {
      this.resetVideo();
      this.pauseVideo();

      this.removeEventListener("leave", this.pauseVideo.bind(this));
      this.removeEventListener(
        "enter-fade-start",
        this.resumeVideoProgress.bind(this)
      );
      this.removeEventListener("video-toggle", this.toggleVideo.bind(this));
      this.removeEventListener(
        "video-time",
        this.setVideoCurrentTime.bind(this)
      );

      this.material.map && this.material.map.dispose();

      Panorama.prototype.dispose.call(this);
    },
  });

  /**
   * @classdesc Google Street View Loader
   * @constructor
   * @param {object} parameters
   */
  function GoogleStreetviewLoader(parameters = {}) {
    this._parameters = parameters;
    this._zoom;
    this._panoId;
    this._panoClient = new google.maps.StreetViewService();
    this._count = 0;
    this._total = 0;
    this._canvas = [];
    this._ctx = [];
    this._wc = 0;
    this._hc = 0;
    this.result = null;
    this.rotation = 0;
    this.copyright = "";
    this.onSizeChange = null;
    this.onPanoramaLoad = null;

    this.levelsW = [1, 2, 4, 7, 13, 26];
    this.levelsH = [1, 1, 2, 4, 7, 13];

    this.widths = [416, 832, 1664, 3328, 6656, 13312];
    this.heights = [416, 416, 832, 1664, 3328, 6656];

    let gl;

    try {
      const canvas = document.createElement("canvas");

      gl = canvas.getContext("experimental-webgl");

      if (!gl) {
        gl = canvas.getContext("webgl");
      }
    } catch (error) {}

    const maxTexSize = Math.max(gl.getParameter(gl.MAX_TEXTURE_SIZE), 6656);
    this.maxW = maxTexSize;
    this.maxH = maxTexSize;
  }

  Object.assign(GoogleStreetviewLoader.prototype, {
    constructor: GoogleStreetviewLoader,

    /**
     * Set progress
     * @param {number} loaded
     * @param {number} total
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    setProgress: function (loaded, total) {
      if (this.onProgress) {
        this.onProgress({ loaded: loaded, total: total });
      }
    },

    /**
     * Throw error
     * @param {string} message
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    throwError: function (message) {
      if (this.onError) {
        this.onError(message);
      } else {
        console.error(message);
      }
    },

    /**
     * Adapt texture to zoom
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    adaptTextureToZoom: function () {
      const w = this.widths[this._zoom];
      const h = this.heights[this._zoom];

      const maxW = this.maxW;
      const maxH = this.maxH;

      this._wc = Math.ceil(w / maxW);
      this._hc = Math.ceil(h / maxH);

      for (let y = 0; y < this._hc; y++) {
        for (let x = 0; x < this._wc; x++) {
          const c = document.createElement("canvas");
          if (x < this._wc - 1) c.width = maxW;
          else c.width = w - maxW * x;
          if (y < this._hc - 1) c.height = maxH;
          else c.height = h - maxH * y;
          this._canvas.push(c);
          this._ctx.push(c.getContext("2d"));
        }
      }
    },

    /**
     * Compose from tile
     * @param {number} x
     * @param {number} y
     * @param {*} texture
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    composeFromTile: function (x, y, texture) {
      const maxW = this.maxW;
      const maxH = this.maxH;

      x *= 512;
      y *= 512;

      const px = Math.floor(x / maxW);
      const py = Math.floor(y / maxH);

      x -= px * maxW;
      y -= py * maxH;

      this._ctx[py * this._wc + px].drawImage(
        texture,
        0,
        0,
        texture.width,
        texture.height,
        x,
        y,
        512,
        512
      );

      this.progress();
    },

    /**
     * Progress
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    progress: function () {
      this._count++;

      this.setProgress(this._count, this._total);

      if (this._count === this._total) {
        this.canvas = this._canvas;
        this.panoId = this._panoId;
        this.zoom = this._zoom;

        if (this.onPanoramaLoad) {
          this.onPanoramaLoad(this._canvas[0]);
        }
      }
    },

    /**
     * Load google street view by id
     * @param {string} id
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    loadFromId: function (id) {
      this._panoId = id;
      this.composePanorama();
    },

    /**
     * Compose panorama
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    composePanorama: function () {
      this.setProgress(0, 1);

      const w = this.levelsW[this._zoom];
      const h = this.levelsH[this._zoom];
      const self = this;

      this._count = 0;
      this._total = w * h;

      const { useWebGL } = this._parameters;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const url =
            "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" +
            this._zoom +
            "&x=" +
            x +
            "&y=" +
            y +
            "&panoid=" +
            this._panoId +
            "&nbt&fover=2";
          (function (x, y) {
            if (useWebGL) {
              const texture = TextureLoader.load(url, null, function () {
                self.composeFromTile(x, y, texture);
              });
            } else {
              const img = new Image();
              img.addEventListener("load", function () {
                self.composeFromTile(x, y, this);
              });
              img.crossOrigin = "";
              img.src = url;
            }
          })(x, y);
        }
      }
    },

    /**
     * Load
     * @param {string} panoid
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    load: function (panoid) {
      this.loadPano(panoid);
    },

    /**
     * Load panorama
     * @param {string} id
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    loadPano: function (id) {
      const self = this;
      this._panoClient.getPanoramaById(id, function (result, status) {
        if (status === google.maps.StreetViewStatus.OK) {
          self.result = result;
          if (self.onPanoramaData) self.onPanoramaData(result);
          /*
           * var h = google.maps.geometry.spherical.computeHeading(location, result.location.latLng);
           * rotation = (result.tiles.centerHeading - h) * Math.PI / 180.0;
           */
          self.copyright = result.copyright;
          self._panoId = result.location.pano;
          self.location = location;
          self.composePanorama();
        } else {
          if (self.onNoPanoramaData) self.onNoPanoramaData(status);
          self.throwError(
            "Could not retrieve panorama for the following reason: " + status
          );
        }
      });
    },

    /**
     * Set zoom level
     * @param {number} z
     * @memberOf GoogleStreetviewLoader
     * @instance
     */
    setZoom: function (z) {
      this._zoom = z;
      this.adaptTextureToZoom();
    },
  });

  /**
   * @classdesc Google streetview panorama
   * @description [How to get Panorama ID]{@link http://stackoverflow.com/questions/29916149/google-maps-streetview-how-to-get-panorama-id}
   * @constructor
   * @param {string} panoId - Panorama id from Google Streetview
   * @param {string} [apiKey] - Google Street View API Key
   */
  function GoogleStreetviewPanorama(panoId, apiKey) {
    ImagePanorama.call(this);

    this.panoId = panoId;

    this.gsvLoader = undefined;

    this.loadRequested = false;

    this.setupGoogleMapAPI(apiKey);
  }

  GoogleStreetviewPanorama.prototype = Object.assign(
    Object.create(ImagePanorama.prototype),
    {
      constructor: GoogleStreetviewPanorama,

      /**
       * Load Google Street View by panorama id
       * @param {string} panoId - Gogogle Street View panorama id
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      load: function (panoId) {
        this.loadRequested = true;

        panoId = panoId || this.panoId || {};

        if (panoId && this.gsvLoader) {
          this.loadGSVLoader(panoId);
        } else {
          this.gsvLoader = {};
        }
      },

      /**
       * Setup Google Map API
       * @param {string}  apiKey
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      setupGoogleMapAPI: function (apiKey) {
        const script = document.createElement("script");
        script.src = "https://maps.googleapis.com/maps/api/js?";
        script.src += apiKey ? "key=" + apiKey : "";
        script.onreadystatechange = this.setGSVLoader.bind(this);
        script.onload = this.setGSVLoader.bind(this);

        document.querySelector("head").appendChild(script);
      },

      /**
       * Set GSV Loader
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      setGSVLoader: function () {
        this.gsvLoader = new GoogleStreetviewLoader();

        if (this.gsvLoader === {} || this.loadRequested) {
          this.load();
        }
      },

      /**
       * Get GSV Loader
       * @memberOf GoogleStreetviewPanorama
       * @instance
       * @return {GoogleStreetviewLoader} GSV Loader instance
       */
      getGSVLoader: function () {
        return this.gsvLoader;
      },

      /**
       * Load GSV Loader
       * @param  {string} panoId - Gogogle Street View panorama id
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      loadGSVLoader: function (panoId) {
        this.loadRequested = false;

        this.gsvLoader.onProgress = this.onProgress.bind(this);

        this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this);

        this.gsvLoader.setZoom(this.getZoomLevel());

        this.gsvLoader.load(panoId);

        this.gsvLoader.loaded = true;
      },

      /**
       * This will be called when panorama is loaded
       * @param  {HTMLCanvasElement} canvas - Canvas where the tiles have been drawn
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      onLoad: function (canvas) {
        if (!this.gsvLoader) {
          return;
        }

        ImagePanorama.prototype.onLoad.call(this, new THREE.Texture(canvas));
      },

      /**
       * Reset
       * @memberOf GoogleStreetviewPanorama
       * @instance
       */
      reset: function () {
        this.gsvLoader = undefined;

        ImagePanorama.prototype.reset.call(this);
      },
    }
  );

  /**
   * Stereographic projection shader
   * based on http://notlion.github.io/streetview-stereographic
   * @author pchen66
   */

  /**
   * @description Stereograhpic Shader
   * @module StereographicShader
   * @property {object} uniforms
   * @property {THREE.Texture} uniforms.tDiffuse diffuse map
   * @property {number} uniforms.resolution image resolution
   * @property {THREE.Matrix4} uniforms.transform transformation matrix
   * @property {number} uniforms.zoom image zoom factor
   * @property {number} uniforms.opacity image opacity
   * @property {string} vertexShader vertex shader
   * @property {string} fragmentShader fragment shader
   */
  const StereographicShader = {
    uniforms: {
      tDiffuse: { value: new THREE.Texture() },
      resolution: { value: 1.0 },
      transform: { value: new THREE.Matrix4() },
      zoom: { value: 1.0 },
      opacity: { value: 1.0 },
    },

    vertexShader: [
      "varying vec2 vUv;",

      "void main() {",

      "vUv = uv;",
      "gl_Position = vec4( position, 1.0 );",

      "}",
    ].join("\n"),

    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float resolution;",
      "uniform mat4 transform;",
      "uniform float zoom;",
      "uniform float opacity;",

      "varying vec2 vUv;",

      "const float PI = 3.141592653589793;",

      "void main(){",

      "vec2 position = -1.0 +  2.0 * vUv;",

      "position *= vec2( zoom * resolution, zoom * 0.5 );",

      "float x2y2 = position.x * position.x + position.y * position.y;",
      "vec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );",

      "sphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );",

      "vec2 sampleUV = vec2(",
      "(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,",
      "(asin(sphere_pnt.z) / PI + 0.5)",
      ");",

      "gl_FragColor = texture2D( tDiffuse, sampleUV );",

      "gl_FragColor.a *= opacity;",

      "}",
    ].join("\n"),
  };

  /**
   * @classdesc Little Planet
   * @constructor
   * @param {string} type 		- Type of little planet basic class
   * @param {string} source 		- URL for the image source
   * @param {number} [size=10000] - Size of plane geometry
   * @param {number} [ratio=0.5]  - Ratio of plane geometry's height against width
   */
  function LittlePlanet(type = "image", source, size = 10000, ratio = 0.5) {
    if (type === "image") {
      ImagePanorama.call(
        this,
        source,
        this.createGeometry(size, ratio),
        this.createMaterial(size)
      );
    }

    this.size = size;
    this.ratio = ratio;
    this.EPS = 0.000001;
    this.frameId;

    this.dragging = false;
    this.userMouse = new THREE.Vector2();

    this.quatA = new THREE.Quaternion();
    this.quatB = new THREE.Quaternion();
    this.quatCur = new THREE.Quaternion();
    this.quatSlerp = new THREE.Quaternion();

    this.vectorX = new THREE.Vector3(1, 0, 0);
    this.vectorY = new THREE.Vector3(0, 1, 0);

    this.addEventListener("window-resize", this.onWindowResize);
  }

  LittlePlanet.prototype = Object.assign(
    Object.create(ImagePanorama.prototype),
    {
      constructor: LittlePlanet,

      add: function (object) {
        if (arguments.length > 1) {
          for (let i = 0; i < arguments.length; i++) {
            this.add(argument);
          }

          return this;
        }

        if (object instanceof Infospot) {
          object.material.depthTest = false;
        }

        ImagePanorama.prototype.add.call(this, object);
      },

      createGeometry: function (size, ratio) {
        return new THREE.PlaneBufferGeometry(size, size * ratio);
      },

      createMaterial: function (size) {
        const shader = StereographicShader,
          uniforms = shader.uniforms;

        uniforms.zoom.value = size;
        uniforms.opacity.value = 0.0;

        return new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: THREE.BackSide,
          transparent: true,
        });
      },

      registerMouseEvents: function () {
        this.container.addEventListener(
          "mousedown",
          this.onMouseDown.bind(this),
          { passive: true }
        );
        this.container.addEventListener(
          "mousemove",
          this.onMouseMove.bind(this),
          { passive: true }
        );
        this.container.addEventListener("mouseup", this.onMouseUp.bind(this), {
          passive: true,
        });
        this.container.addEventListener(
          "touchstart",
          this.onMouseDown.bind(this),
          { passive: true }
        );
        this.container.addEventListener(
          "touchmove",
          this.onMouseMove.bind(this),
          { passive: true }
        );
        this.container.addEventListener("touchend", this.onMouseUp.bind(this), {
          passive: true,
        });
        this.container.addEventListener(
          "mousewheel",
          this.onMouseWheel.bind(this),
          { passive: false }
        );
        this.container.addEventListener(
          "DOMMouseScroll",
          this.onMouseWheel.bind(this),
          { passive: false }
        );
        this.container.addEventListener(
          "contextmenu",
          this.onContextMenu.bind(this),
          { passive: true }
        );
      },

      unregisterMouseEvents: function () {
        this.container.removeEventListener(
          "mousedown",
          this.onMouseDown.bind(this),
          false
        );
        this.container.removeEventListener(
          "mousemove",
          this.onMouseMove.bind(this),
          false
        );
        this.container.removeEventListener(
          "mouseup",
          this.onMouseUp.bind(this),
          false
        );
        this.container.removeEventListener(
          "touchstart",
          this.onMouseDown.bind(this),
          false
        );
        this.container.removeEventListener(
          "touchmove",
          this.onMouseMove.bind(this),
          false
        );
        this.container.removeEventListener(
          "touchend",
          this.onMouseUp.bind(this),
          false
        );
        this.container.removeEventListener(
          "mousewheel",
          this.onMouseWheel.bind(this),
          false
        );
        this.container.removeEventListener(
          "DOMMouseScroll",
          this.onMouseWheel.bind(this),
          false
        );
        this.container.removeEventListener(
          "contextmenu",
          this.onContextMenu.bind(this),
          false
        );
      },

      onMouseDown: function (event) {
        const inputCount = (event.touches && event.touches.length) || 1;

        switch (inputCount) {
          case 1:
            const x =
              event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
            const y =
              event.clientY >= 0 ? event.clientY : event.touches[0].clientY;

            this.dragging = true;
            this.userMouse.set(x, y);

            break;

          case 2:
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            this.userMouse.pinchDistance = distance;

            break;

          default:
            break;
        }

        this.onUpdateCallback();
      },

      onMouseMove: function (event) {
        const inputCount = (event.touches && event.touches.length) || 1;

        switch (inputCount) {
          case 1:
            const x =
              event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
            const y =
              event.clientY >= 0 ? event.clientY : event.touches[0].clientY;

            const angleX = THREE.Math.degToRad(x - this.userMouse.x) * 0.4;
            const angleY = THREE.Math.degToRad(y - this.userMouse.y) * 0.4;

            if (this.dragging) {
              this.quatA.setFromAxisAngle(this.vectorY, angleX);
              this.quatB.setFromAxisAngle(this.vectorX, angleY);
              this.quatCur.multiply(this.quatA).multiply(this.quatB);
              this.userMouse.set(x, y);
            }

            break;

          case 2:
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            this.addZoomDelta(this.userMouse.pinchDistance - distance);

            break;

          default:
            break;
        }
      },

      onMouseUp: function (event) {
        this.dragging = false;
      },

      onMouseWheel: function (event) {
        event.preventDefault();
        event.stopPropagation();

        let delta = 0;

        if (event.wheelDelta !== undefined) {
          // WebKit / Opera / Explorer 9

          delta = event.wheelDelta;
        } else if (event.detail !== undefined) {
          // Firefox

          delta = -event.detail;
        }

        this.addZoomDelta(delta);
        this.onUpdateCallback();
      },

      addZoomDelta: function (delta) {
        const uniforms = this.material.uniforms;
        const lowerBound = this.size * 0.1;
        const upperBound = this.size * 10;

        uniforms.zoom.value += delta;

        if (uniforms.zoom.value <= lowerBound) {
          uniforms.zoom.value = lowerBound;
        } else if (uniforms.zoom.value >= upperBound) {
          uniforms.zoom.value = upperBound;
        }
      },

      onUpdateCallback: function () {
        this.frameId = requestAnimationFrame(this.onUpdateCallback.bind(this));

        this.quatSlerp.slerp(this.quatCur, 0.1);
        this.material.uniforms.transform.value.makeRotationFromQuaternion(
          this.quatSlerp
        );

        if (
          !this.dragging &&
          1.0 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS
        ) {
          cancelAnimationFrame(this.frameId);
        }
      },

      reset: function () {
        this.quatCur.set(0, 0, 0, 1);
        this.quatSlerp.set(0, 0, 0, 1);
        this.onUpdateCallback();
      },

      onLoad: function () {
        this.material.uniforms.resolution.value =
          this.container.clientWidth / this.container.clientHeight;

        this.registerMouseEvents();
        this.onUpdateCallback();

        this.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "disableControl",
        });
      },

      onLeave: function () {
        this.unregisterMouseEvents();

        this.dispatchEvent({
          type: "panolens-viewer-handler",
          method: "enableControl",
          data: CONTROLS.ORBIT,
        });

        cancelAnimationFrame(this.frameId);

        ImagePanorama.prototype.onLeave.call(this);
      },

      onWindowResize: function () {
        this.material.uniforms.resolution.value =
          this.container.clientWidth / this.container.clientHeight;
      },

      onContextMenu: function () {
        this.dragging = false;
      },

      dispose: function () {
        ImagePanorama.prototype.dispose.call(this);
      },
    }
  );

  /**
   * @classdesc Image Little Planet
   * @constructor
   * @param {string} source 		- URL for the image source
   * @param {number} [size=10000] - Size of plane geometry
   * @param {number} [ratio=0.5]  - Ratio of plane geometry's height against width
   */
  function ImageLittlePlanet(source, size, ratio) {
    LittlePlanet.call(this, "image", source, size, ratio);
  }

  ImageLittlePlanet.prototype = Object.assign(
    Object.create(LittlePlanet.prototype),
    {
      constructor: ImageLittlePlanet,

      /**
       * On loaded with texture
       * @param {THREE.Texture} texture
       * @memberOf ImageLittlePlanet
       * @instance
       */
      onLoad: function (texture) {
        this.updateTexture(texture);

        LittlePlanet.prototype.onLoad.call(this);
        ImagePanorama.prototype.onLoad.call(this, texture);
      },

      /**
       * Update texture
       * @param {THREE.Texture} texture
       * @memberOf ImageLittlePlanet
       * @instance
       */
      updateTexture: function (texture) {
        texture.minFilter = texture.magFilter = THREE.LinearFilter;

        this.material.uniforms["tDiffuse"].value = texture;
      },

      /**
       * Dispose
       * @memberOf ImageLittlePlanet
       * @instance
       */
      dispose: function () {
        const tDiffuse = this.material.uniforms["tDiffuse"];

        if (tDiffuse && tDiffuse.value) {
          tDiffuse.value.dispose();
        }

        LittlePlanet.prototype.dispose.call(this);
      },
    }
  );

  /**
   * @classdesc Camera panorama
   * @description See {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints|MediaStreamConstraints} for constraints
   * @param {object} - camera constraints
   * @constructor
   */
  function CameraPanorama(constraints) {
    const radius = 5000;
    const geometry = new THREE.SphereBufferGeometry(radius, 60, 40);
    const material = new THREE.MeshBasicMaterial({ visible: false });

    Panorama.call(this, geometry, material);

    this.media = new Media(constraints);
    this.radius = radius;

    this.addEventListener("enter", this.start.bind(this));
    this.addEventListener("leave", this.stop.bind(this));
    this.addEventListener(
      "panolens-container",
      this.onPanolensContainer.bind(this)
    );
    this.addEventListener("panolens-scene", this.onPanolensScene.bind(this));
  }

  CameraPanorama.prototype = Object.assign(Object.create(Panorama.prototype), {
    constructor: CameraPanorama,

    /**
     * On container event
     * @param {object} event
     * @memberOf CameraPanorama
     * @instance
     */
    onPanolensContainer: function ({ container }) {
      this.media.container = container;
    },

    /**
     * On scene event
     * @param {object} event
     * @memberOf CameraPanorama
     * @instance
     */
    onPanolensScene: function ({ scene }) {
      this.media.scene = scene;
    },

    /**
     * Start camera streaming
     * @memberOf CameraPanorama
     * @instance
     * @returns {Promise}
     */
    start: function () {
      return this.media.start();
    },

    /**
     * Stop camera streaming
     * @memberOf CameraPanorama
     * @instance
     */
    stop: function () {
      this.media.stop();
    },
  });

  /**
   * @classdesc Orbit Controls
   * @constructor
   * @external OrbitControls
   * @param {THREE.Object} object
   * @param {HTMLElement} domElement
   */
  function OrbitControls(object, domElement) {
    this.object = object;
    this.domElement = domElement !== undefined ? domElement : document;
    this.frameId;

    // API

    // Set to false to disable this control
    this.enabled = true;

    /*
     * "target" sets the location of focus, where the control orbits around
     * and where it pans with respect to.
     */
    this.target = new THREE.Vector3();

    // center is old, deprecated; use "target" instead
    this.center = this.target;

    /*
     * This option actually enables dollying in and out; left as "zoom" for
     * backwards compatibility
     */
    this.noZoom = false;
    this.zoomSpeed = 1.0;

    // Limits to how far you can dolly in and out ( PerspectiveCamera only )
    this.minDistance = 0;
    this.maxDistance = Infinity;

    // Limits to how far you can zoom in and out ( OrthographicCamera only )
    this.minZoom = 0;
    this.maxZoom = Infinity;

    // Set to true to disable this control
    this.noRotate = false;
    this.rotateSpeed = -0.15;

    // Set to true to disable this control
    this.noPan = true;
    this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    this.autoRotate = false;
    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    /*
     * How far you can orbit vertically, upper and lower limits.
     * Range is 0 to Math.PI radians.
     */
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians

    // Momentum
    this.momentumDampingFactor = 0.9;
    this.momentumScalingFactor = -0.005;
    this.momentumKeydownFactor = 20;

    // Fov
    this.minFov = 30;
    this.maxFov = 120;

    /*
     * How far you can orbit horizontally, upper and lower limits.
     * If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
     */
    this.minAzimuthAngle = -Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians

    // Set to true to disable use of the keys
    this.noKeys = false;

    // The four arrow keys
    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

    // Mouse buttons
    this.mouseButtons = {
      ORBIT: THREE.MOUSE.LEFT,
      ZOOM: THREE.MOUSE.MIDDLE,
      PAN: THREE.MOUSE.RIGHT,
    };

    /*
     * //////////
     * internals
     */

    var scope = this;

    var EPS = 10e-8;
    var MEPS = 10e-5;

    var rotateStart = new THREE.Vector2();
    var rotateEnd = new THREE.Vector2();
    var rotateDelta = new THREE.Vector2();

    var panStart = new THREE.Vector2();
    var panEnd = new THREE.Vector2();
    var panDelta = new THREE.Vector2();
    var panOffset = new THREE.Vector3();

    var offset = new THREE.Vector3();

    var dollyStart = new THREE.Vector2();
    var dollyEnd = new THREE.Vector2();
    var dollyDelta = new THREE.Vector2();

    var theta;
    var phi;
    var phiDelta = 0;
    var thetaDelta = 0;
    var scale = 1;
    var pan = new THREE.Vector3();

    var lastPosition = new THREE.Vector3();
    var lastQuaternion = new THREE.Quaternion();

    var momentumLeft = 0,
      momentumUp = 0;
    var eventPrevious;
    var momentumOn = false;

    var keyUp, keyBottom, keyLeft, keyRight;

    var STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_DOLLY: 4,
      TOUCH_PAN: 5,
    };

    var state = STATE.NONE;

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;

    // so camera.up is the orbit axis

    var quat = new THREE.Quaternion().setFromUnitVectors(
      object.up,
      new THREE.Vector3(0, 1, 0)
    );
    var quatInverse = quat.clone().inverse();

    // events

    var changeEvent = { type: "change" };
    var startEvent = { type: "start" };
    var endEvent = { type: "end" };

    this.setLastQuaternion = function (quaternion) {
      lastQuaternion.copy(quaternion);
      scope.object.quaternion.copy(quaternion);
    };

    this.getLastPosition = function () {
      return lastPosition;
    };

    this.rotateLeft = function (angle) {
      if (angle === undefined) {
        angle = getAutoRotationAngle();
      }

      thetaDelta -= angle;
    };

    this.rotateUp = function (angle) {
      if (angle === undefined) {
        angle = getAutoRotationAngle();
      }

      phiDelta -= angle;
    };

    // pass in distance in world space to move left
    this.panLeft = function (distance) {
      var te = this.object.matrix.elements;

      // get X column of matrix
      panOffset.set(te[0], te[1], te[2]);
      panOffset.multiplyScalar(-distance);

      pan.add(panOffset);
    };

    // pass in distance in world space to move up
    this.panUp = function (distance) {
      var te = this.object.matrix.elements;

      // get Y column of matrix
      panOffset.set(te[4], te[5], te[6]);
      panOffset.multiplyScalar(distance);

      pan.add(panOffset);
    };

    /*
     * pass in x,y of change desired in pixel space,
     * right and down are positive
     */
    this.pan = function (deltaX, deltaY) {
      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;

      if (scope.object instanceof THREE.PerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        var offset = position.clone().sub(scope.target);
        var targetDistance = offset.length();

        // half of the fov is center to top of screen
        targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0);

        // we actually don't use screenWidth, since perspective camera is fixed to screen height
        scope.panLeft((2 * deltaX * targetDistance) / element.clientHeight);
        scope.panUp((2 * deltaY * targetDistance) / element.clientHeight);
      } else if (scope.object instanceof THREE.OrthographicCamera) {
        // orthographic
        scope.panLeft(
          (deltaX * (scope.object.right - scope.object.left)) /
            element.clientWidth
        );
        scope.panUp(
          (deltaY * (scope.object.top - scope.object.bottom)) /
            element.clientHeight
        );
      } else {
        // camera neither orthographic or perspective
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
        );
      }
    };

    this.momentum = function () {
      if (!momentumOn) return;

      if (Math.abs(momentumLeft) < MEPS && Math.abs(momentumUp) < MEPS) {
        momentumOn = false;
        return;
      }

      momentumUp *= this.momentumDampingFactor;
      momentumLeft *= this.momentumDampingFactor;

      thetaDelta -= this.momentumScalingFactor * momentumLeft;
      phiDelta -= this.momentumScalingFactor * momentumUp;
    };

    this.dollyIn = function (dollyScale) {
      if (dollyScale === undefined) {
        dollyScale = getZoomScale();
      }

      if (scope.object instanceof THREE.PerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object instanceof THREE.OrthographicCamera) {
        scope.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom * dollyScale)
        );
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        );
      }
    };

    this.dollyOut = function (dollyScale) {
      if (dollyScale === undefined) {
        dollyScale = getZoomScale();
      }

      if (scope.object instanceof THREE.PerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object instanceof THREE.OrthographicCamera) {
        scope.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / dollyScale)
        );
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        );
      }
    };

    this.update = function (ignoreUpdate) {
      var position = this.object.position;

      offset.copy(position).sub(this.target);

      // rotate offset to "y-axis-is-up" space
      offset.applyQuaternion(quat);

      // angle from z-axis around y-axis

      theta = Math.atan2(offset.x, offset.z);

      // angle from y-axis

      phi = Math.atan2(
        Math.sqrt(offset.x * offset.x + offset.z * offset.z),
        offset.y
      );

      if (this.autoRotate && state === STATE.NONE) {
        this.rotateLeft(getAutoRotationAngle());
      }

      this.momentum();

      theta += thetaDelta;
      phi += phiDelta;

      // restrict theta to be between desired limits
      theta = Math.max(
        this.minAzimuthAngle,
        Math.min(this.maxAzimuthAngle, theta)
      );

      // restrict phi to be between desired limits
      phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

      // restrict phi to be betwee EPS and PI-EPS
      phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

      var radius = offset.length() * scale;

      // restrict radius to be between desired limits
      radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

      // move target to panned location
      this.target.add(pan);

      offset.x = radius * Math.sin(phi) * Math.sin(theta);
      offset.y = radius * Math.cos(phi);
      offset.z = radius * Math.sin(phi) * Math.cos(theta);

      // rotate offset back to "camera-up-vector-is-up" space
      offset.applyQuaternion(quatInverse);

      position.copy(this.target).add(offset);

      this.object.lookAt(this.target);

      thetaDelta = 0;
      phiDelta = 0;
      scale = 1;
      pan.set(0, 0, 0);

      /*
       * update condition is:
       * min(camera displacement, camera rotation in radians)^2 > EPS
       * using small-angle approximation cos(x/2) = 1 - x^2 / 8
       */
      if (
        lastPosition.distanceToSquared(this.object.position) > EPS ||
        8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS
      ) {
        ignoreUpdate !== true && this.dispatchEvent(changeEvent);

        lastPosition.copy(this.object.position);
        lastQuaternion.copy(this.object.quaternion);
      }
    };

    this.reset = function () {
      state = STATE.NONE;

      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.zoom = this.zoom0;

      this.object.updateProjectionMatrix();
      this.dispatchEvent(changeEvent);

      this.update();
    };

    this.getPolarAngle = function () {
      return phi;
    };

    this.getAzimuthalAngle = function () {
      return theta;
    };

    function getAutoRotationAngle() {
      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
    }

    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }

    function onMouseDown(event) {
      momentumOn = false;

      momentumLeft = momentumUp = 0;

      if (scope.enabled === false) return;
      event.preventDefault();

      if (event.button === scope.mouseButtons.ORBIT) {
        if (scope.noRotate === true) return;

        state = STATE.ROTATE;

        rotateStart.set(event.clientX, event.clientY);
      } else if (event.button === scope.mouseButtons.ZOOM) {
        if (scope.noZoom === true) return;

        state = STATE.DOLLY;

        dollyStart.set(event.clientX, event.clientY);
      } else if (event.button === scope.mouseButtons.PAN) {
        if (scope.noPan === true) return;

        state = STATE.PAN;

        panStart.set(event.clientX, event.clientY);
      }

      if (state !== STATE.NONE) {
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mouseup", onMouseUp, false);
        scope.dispatchEvent(startEvent);
      }

      scope.update();
    }

    function onMouseMove(event) {
      if (scope.enabled === false) return;

      event.preventDefault();

      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;

      if (state === STATE.ROTATE) {
        if (scope.noRotate === true) return;

        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart);

        // rotating across whole screen goes 360 degrees around
        scope.rotateLeft(
          ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
            scope.rotateSpeed
        );

        // rotating up and down along whole screen attempts to go 360, but limited to 180
        scope.rotateUp(
          ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
            scope.rotateSpeed
        );

        rotateStart.copy(rotateEnd);

        if (eventPrevious) {
          momentumLeft = event.clientX - eventPrevious.clientX;
          momentumUp = event.clientY - eventPrevious.clientY;
        }

        eventPrevious = event;
      } else if (state === STATE.DOLLY) {
        if (scope.noZoom === true) return;

        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);

        if (dollyDelta.y > 0) {
          scope.dollyIn();
        } else if (dollyDelta.y < 0) {
          scope.dollyOut();
        }

        dollyStart.copy(dollyEnd);
      } else if (state === STATE.PAN) {
        if (scope.noPan === true) return;

        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart);

        scope.pan(panDelta.x, panDelta.y);

        panStart.copy(panEnd);
      }

      if (state !== STATE.NONE) scope.update();
    }

    function onMouseUp(/* event */) {
      momentumOn = true;

      eventPrevious = undefined;

      if (scope.enabled === false) return;

      document.removeEventListener("mousemove", onMouseMove, false);
      document.removeEventListener("mouseup", onMouseUp, false);
      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }

    function onMouseWheel(event) {
      if (
        scope.enabled === false ||
        scope.noZoom === true ||
        state !== STATE.NONE
      )
        return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta !== undefined) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta;
      } else if (event.detail !== undefined) {
        // Firefox

        delta = -event.detail;
      }

      if (delta > 0) {
        // scope.dollyOut();
        scope.object.fov =
          scope.object.fov < scope.maxFov ? scope.object.fov + 1 : scope.maxFov;
        scope.object.updateProjectionMatrix();
      } else if (delta < 0) {
        // scope.dollyIn();
        scope.object.fov =
          scope.object.fov > scope.minFov ? scope.object.fov - 1 : scope.minFov;
        scope.object.updateProjectionMatrix();
      }

      scope.update();
      scope.dispatchEvent(changeEvent);
      scope.dispatchEvent(startEvent);
      scope.dispatchEvent(endEvent);
    }

    function onKeyUp(event) {
      switch (event.keyCode) {
        case scope.keys.UP:
          keyUp = false;
          break;

        case scope.keys.BOTTOM:
          keyBottom = false;
          break;

        case scope.keys.LEFT:
          keyLeft = false;
          break;

        case scope.keys.RIGHT:
          keyRight = false;
          break;
      }
    }

    function onKeyDown(event) {
      if (
        scope.enabled === false ||
        scope.noKeys === true ||
        scope.noRotate === true
      )
        return;

      switch (event.keyCode) {
        case scope.keys.UP:
          keyUp = true;
          break;

        case scope.keys.BOTTOM:
          keyBottom = true;
          break;

        case scope.keys.LEFT:
          keyLeft = true;
          break;

        case scope.keys.RIGHT:
          keyRight = true;
          break;
      }

      if (keyUp || keyBottom || keyLeft || keyRight) {
        momentumOn = true;

        if (keyUp)
          momentumUp = -scope.rotateSpeed * scope.momentumKeydownFactor;
        if (keyBottom)
          momentumUp = scope.rotateSpeed * scope.momentumKeydownFactor;
        if (keyLeft)
          momentumLeft = -scope.rotateSpeed * scope.momentumKeydownFactor;
        if (keyRight)
          momentumLeft = scope.rotateSpeed * scope.momentumKeydownFactor;
      }
    }

    function touchstart(event) {
      momentumOn = false;

      momentumLeft = momentumUp = 0;

      if (scope.enabled === false) return;

      switch (event.touches.length) {
        case 1: // one-fingered touch: rotate
          if (scope.noRotate === true) return;

          state = STATE.TOUCH_ROTATE;

          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
          break;

        case 2: // two-fingered touch: dolly
          if (scope.noZoom === true) return;

          state = STATE.TOUCH_DOLLY;

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyStart.set(0, distance);

          break;

        case 3: // three-fingered touch: pan
          if (scope.noPan === true) return;

          state = STATE.TOUCH_PAN;

          panStart.set(event.touches[0].pageX, event.touches[0].pageY);
          break;

        default:
          state = STATE.NONE;
      }

      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (scope.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;

      switch (event.touches.length) {
        case 1: // one-fingered touch: rotate
          if (scope.noRotate === true) return;
          if (state !== STATE.TOUCH_ROTATE) return;

          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          rotateDelta.subVectors(rotateEnd, rotateStart);

          // rotating across whole screen goes 360 degrees around
          scope.rotateLeft(
            ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
              scope.rotateSpeed
          );
          // rotating up and down along whole screen attempts to go 360, but limited to 180
          scope.rotateUp(
            ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
              scope.rotateSpeed
          );

          rotateStart.copy(rotateEnd);

          if (eventPrevious) {
            momentumLeft = event.touches[0].pageX - eventPrevious.pageX;
            momentumUp = event.touches[0].pageY - eventPrevious.pageY;
          }

          eventPrevious = {
            pageX: event.touches[0].pageX,
            pageY: event.touches[0].pageY,
          };

          scope.update();
          break;

        case 2: // two-fingered touch: dolly
          if (scope.noZoom === true) return;
          if (state !== STATE.TOUCH_DOLLY) return;

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyEnd.set(0, distance);
          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y < 0) {
            scope.object.fov =
              scope.object.fov < scope.maxFov
                ? scope.object.fov + 1
                : scope.maxFov;
            scope.object.updateProjectionMatrix();
          } else if (dollyDelta.y > 0) {
            scope.object.fov =
              scope.object.fov > scope.minFov
                ? scope.object.fov - 1
                : scope.minFov;
            scope.object.updateProjectionMatrix();
          }

          dollyStart.copy(dollyEnd);

          scope.update();
          scope.dispatchEvent(changeEvent);
          break;

        case 3: // three-fingered touch: pan
          if (scope.noPan === true) return;
          if (state !== STATE.TOUCH_PAN) return;

          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          panDelta.subVectors(panEnd, panStart);

          scope.pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
          break;

        default:
          state = STATE.NONE;
      }
    }

    function touchend(/* event */) {
      momentumOn = true;

      eventPrevious = undefined;

      if (scope.enabled === false) return;

      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }

    // this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
    this.domElement.addEventListener("mousedown", onMouseDown, {
      passive: false,
    });
    this.domElement.addEventListener("mousewheel", onMouseWheel, {
      passive: false,
    });
    this.domElement.addEventListener("DOMMouseScroll", onMouseWheel, {
      passive: false,
    }); // firefox

    this.domElement.addEventListener("touchstart", touchstart, {
      passive: false,
    });
    this.domElement.addEventListener("touchend", touchend, { passive: false });
    this.domElement.addEventListener("touchmove", touchmove, {
      passive: false,
    });

    window.addEventListener("keyup", onKeyUp, { passive: false });
    window.addEventListener("keydown", onKeyDown, { passive: false });

    // force an update at start
    this.update();
  }
  OrbitControls.prototype = Object.assign(
    Object.create(THREE.EventDispatcher.prototype),
    {
      constructor: OrbitControls,
    }
  );

  /**
   * @classdesc Device Orientation Control
   * @constructor
   * @external DeviceOrientationControls
   * @param {THREE.Camera} camera
   * @param {HTMLElement} domElement
   */
  function DeviceOrientationControls(camera, domElement) {
    var scope = this;
    var changeEvent = { type: "change" };

    var rotY = 0;
    var rotX = 0;
    var tempX = 0;
    var tempY = 0;

    this.camera = camera;
    this.camera.rotation.reorder("YXZ");
    this.domElement = domElement !== undefined ? domElement : document;

    this.enabled = true;

    this.deviceOrientation = {};
    this.screenOrientation = 0;

    this.alpha = 0;
    this.alphaOffsetAngle = 0;

    var onDeviceOrientationChangeEvent = function (event) {
      scope.deviceOrientation = event;
    };

    var onScreenOrientationChangeEvent = function () {
      scope.screenOrientation = window.orientation || 0;
    };

    var onTouchStartEvent = function (event) {
      event.preventDefault();
      event.stopPropagation();

      tempX = event.touches[0].pageX;
      tempY = event.touches[0].pageY;
    };

    var onTouchMoveEvent = function (event) {
      event.preventDefault();
      event.stopPropagation();

      rotY += THREE.Math.degToRad((event.touches[0].pageX - tempX) / 4);
      rotX += THREE.Math.degToRad((tempY - event.touches[0].pageY) / 4);

      scope.updateAlphaOffsetAngle(rotY);

      tempX = event.touches[0].pageX;
      tempY = event.touches[0].pageY;
    };

    // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

    var setCameraQuaternion = function (
      quaternion,
      alpha,
      beta,
      gamma,
      orient
    ) {
      var zee = new THREE.Vector3(0, 0, 1);

      var euler = new THREE.Euler();

      var q0 = new THREE.Quaternion();

      var q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

      var vectorFingerY;
      var fingerQY = new THREE.Quaternion();
      var fingerQX = new THREE.Quaternion();

      if (scope.screenOrientation == 0) {
        vectorFingerY = new THREE.Vector3(1, 0, 0);
        fingerQY.setFromAxisAngle(vectorFingerY, -rotX);
      } else if (scope.screenOrientation == 180) {
        vectorFingerY = new THREE.Vector3(1, 0, 0);
        fingerQY.setFromAxisAngle(vectorFingerY, rotX);
      } else if (scope.screenOrientation == 90) {
        vectorFingerY = new THREE.Vector3(0, 1, 0);
        fingerQY.setFromAxisAngle(vectorFingerY, rotX);
      } else if (scope.screenOrientation == -90) {
        vectorFingerY = new THREE.Vector3(0, 1, 0);
        fingerQY.setFromAxisAngle(vectorFingerY, -rotX);
      }

      q1.multiply(fingerQY);
      q1.multiply(fingerQX);

      euler.set(beta, alpha, -gamma, "YXZ"); // 'ZXY' for the device, but 'YXZ' for us

      quaternion.setFromEuler(euler); // orient the device

      quaternion.multiply(q1); // camera looks out the back of the device, not the top

      quaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation
    };

    this.connect = function () {
      onScreenOrientationChangeEvent(); // run once on load

      window.addEventListener(
        "orientationchange",
        onScreenOrientationChangeEvent,
        { passive: true }
      );
      window.addEventListener(
        "deviceorientation",
        onDeviceOrientationChangeEvent,
        { passive: true }
      );
      window.addEventListener("deviceorientation", this.update.bind(this), {
        passive: true,
      });

      scope.domElement.addEventListener("touchstart", onTouchStartEvent, {
        passive: false,
      });
      scope.domElement.addEventListener("touchmove", onTouchMoveEvent, {
        passive: false,
      });

      scope.enabled = true;
    };

    this.disconnect = function () {
      window.removeEventListener(
        "orientationchange",
        onScreenOrientationChangeEvent,
        false
      );
      window.removeEventListener(
        "deviceorientation",
        onDeviceOrientationChangeEvent,
        false
      );
      window.removeEventListener(
        "deviceorientation",
        this.update.bind(this),
        false
      );

      scope.domElement.removeEventListener(
        "touchstart",
        onTouchStartEvent,
        false
      );
      scope.domElement.removeEventListener(
        "touchmove",
        onTouchMoveEvent,
        false
      );

      scope.enabled = false;
    };

    this.update = function (ignoreUpdate) {
      if (scope.enabled === false) return;

      var alpha = scope.deviceOrientation.alpha
        ? THREE.Math.degToRad(scope.deviceOrientation.alpha) +
          scope.alphaOffsetAngle
        : 0; // Z
      var beta = scope.deviceOrientation.beta
        ? THREE.Math.degToRad(scope.deviceOrientation.beta)
        : 0; // X'
      var gamma = scope.deviceOrientation.gamma
        ? THREE.Math.degToRad(scope.deviceOrientation.gamma)
        : 0; // Y''
      var orient = scope.screenOrientation
        ? THREE.Math.degToRad(scope.screenOrientation)
        : 0; // O

      setCameraQuaternion(scope.camera.quaternion, alpha, beta, gamma, orient);
      scope.alpha = alpha;

      ignoreUpdate !== true && scope.dispatchEvent(changeEvent);
    };

    this.updateAlphaOffsetAngle = function (angle) {
      this.alphaOffsetAngle = angle;
      this.update();
    };

    this.dispose = function () {
      this.disconnect();
    };

    this.connect();
  }
  DeviceOrientationControls.prototype = Object.assign(
    Object.create(THREE.EventDispatcher.prototype),
    {
      constructor: DeviceOrientationControls,
    }
  );

  /**
   * @classdesc Google Cardboard Effect Composer
   * @constructor
   * @external CardboardEffect
   * @param {THREE.WebGLRenderer} renderer
   */
  function CardboardEffect(renderer) {
    var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    var _scene = new THREE.Scene();

    var _stereo = new THREE.StereoCamera();
    _stereo.aspect = 0.5;

    var _params = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
    };

    var _renderTarget = new THREE.WebGLRenderTarget(512, 512, _params);
    _renderTarget.scissorTest = true;
    _renderTarget.texture.generateMipmaps = false;

    /*
     * Distortion Mesh ported from:
     * https://github.com/borismus/webvr-boilerplate/blob/master/src/distortion/barrel-distortion-fragment.js
     */

    var distortion = new THREE.Vector2(0.441, 0.156);

    var geometry = new THREE.PlaneBufferGeometry(1, 1, 10, 20)
      .removeAttribute("normal")
      .toNonIndexed();

    var positions = geometry.attributes.position.array;
    var uvs = geometry.attributes.uv.array;

    // duplicate
    geometry.attributes.position.count *= 2;
    geometry.attributes.uv.count *= 2;

    var positions2 = new Float32Array(positions.length * 2);
    positions2.set(positions);
    positions2.set(positions, positions.length);

    var uvs2 = new Float32Array(uvs.length * 2);
    uvs2.set(uvs);
    uvs2.set(uvs, uvs.length);

    var vector = new THREE.Vector2();
    var length = positions.length / 3;

    for (var i = 0, l = positions2.length / 3; i < l; i++) {
      vector.x = positions2[i * 3 + 0];
      vector.y = positions2[i * 3 + 1];

      var dot = vector.dot(vector);
      var scalar = 1.5 + (distortion.x + distortion.y * dot) * dot;

      var offset = i < length ? 0 : 1;

      positions2[i * 3 + 0] = (vector.x / scalar) * 1.5 - 0.5 + offset;
      positions2[i * 3 + 1] = (vector.y / scalar) * 3.0;

      uvs2[i * 2] = (uvs2[i * 2] + offset) * 0.5;
    }

    geometry.attributes.position.array = positions2;
    geometry.attributes.uv.array = uvs2;

    //

    var material = new THREE.MeshBasicMaterial({ map: _renderTarget.texture });
    var mesh = new THREE.Mesh(geometry, material);
    _scene.add(mesh);

    //

    this.setSize = function (width, height) {
      renderer.setSize(width, height);

      var pixelRatio = renderer.getPixelRatio();

      _renderTarget.setSize(width * pixelRatio, height * pixelRatio);
    };

    this.render = function (scene, camera) {
      scene.updateMatrixWorld();

      if (camera.parent === null) camera.updateMatrixWorld();

      _stereo.update(camera);

      var width = _renderTarget.width / 2;
      var height = _renderTarget.height;

      if (renderer.autoClear) renderer.clear();

      _renderTarget.scissor.set(0, 0, width, height);
      _renderTarget.viewport.set(0, 0, width, height);
      renderer.setRenderTarget(_renderTarget);
      renderer.render(scene, _stereo.cameraL);

      renderer.clearDepth();

      _renderTarget.scissor.set(width, 0, width, height);
      _renderTarget.viewport.set(width, 0, width, height);
      renderer.setRenderTarget(_renderTarget);
      renderer.render(scene, _stereo.cameraR);

      renderer.clearDepth();

      renderer.setRenderTarget(null);
      renderer.render(_scene, _camera);
    };
  }

  /**
   * @classdesc Stereo Effect Composer
   * @constructor
   * @external StereoEffect
   * @param {THREE.WebGLRenderer} renderer
   */
  const StereoEffect = function (renderer) {
    var _stereo = new THREE.StereoCamera();
    _stereo.aspect = 0.5;
    var size = new THREE.Vector2();

    this.setEyeSeparation = function (eyeSep) {
      _stereo.eyeSep = eyeSep;
    };

    this.setSize = function (width, height) {
      renderer.setSize(width, height);
    };

    this.render = function (scene, camera) {
      scene.updateMatrixWorld();

      if (camera.parent === null) camera.updateMatrixWorld();

      _stereo.update(camera);

      renderer.getSize(size);

      if (renderer.autoClear) renderer.clear();
      renderer.setScissorTest(true);

      renderer.setScissor(0, 0, size.width / 2, size.height);
      renderer.setViewport(0, 0, size.width / 2, size.height);
      renderer.render(scene, _stereo.cameraL);

      renderer.setScissor(size.width / 2, 0, size.width / 2, size.height);
      renderer.setViewport(size.width / 2, 0, size.width / 2, size.height);
      renderer.render(scene, _stereo.cameraR);

      renderer.setScissorTest(false);
    };
  };

  /**
   * @classdesc Viewer contains pre-defined scene, camera and renderer
   * @constructor
   * @param {object} [options] - Use custom or default config options
   * @param {HTMLElement} [options.container] - A HTMLElement to host the canvas
   * @param {THREE.Scene} [options.scene=THREE.Scene] - A THREE.Scene which contains panorama and 3D objects
   * @param {THREE.Camera} [options.camera=THREE.PerspectiveCamera] - A THREE.Camera to view the scene
   * @param {THREE.WebGLRenderer} [options.renderer=THREE.WebGLRenderer] - A THREE.WebGLRenderer to render canvas
   * @param {boolean} [options.controlBar=true] - Show/hide control bar on the bottom of the container
   * @param {array}   [options.controlButtons=[]] - Button names to mount on controlBar if controlBar exists, Defaults to ['fullscreen', 'setting', 'video']
   * @param {boolean} [options.autoHideControlBar=false] - Auto hide control bar when click on non-active area
   * @param {boolean} [options.autoHideInfospot=true] - Auto hide infospots when click on non-active area
   * @param {boolean} [options.horizontalView=false] - Allow only horizontal camera control
   * @param {number}  [options.clickTolerance=10] - Distance tolerance to tigger click / tap event
   * @param {number}  [options.cameraFov=60] - Camera field of view value
   * @param {boolean} [options.reverseDragging=false] - Reverse dragging direction
   * @param {boolean} [options.enableReticle=false] - Enable reticle for mouseless interaction other than VR mode
   * @param {number}  [options.dwellTime=1500] - Dwell time for reticle selection in ms
   * @param {boolean} [options.autoReticleSelect=true] - Auto select a clickable target after dwellTime
   * @param {boolean} [options.viewIndicator=false] - Adds an angle view indicator in upper left corner
   * @param {number}  [options.indicatorSize=30] - Size of View Indicator
   * @param {string}  [options.output='none'] - Whether and where to output raycast position. Could be 'console' or 'overlay'
   * @param {boolean} [options.autoRotate=false] - Auto rotate
   * @param {number}  [options.autoRotateSpeed=2.0] - Auto rotate speed as in degree per second. Positive is counter-clockwise and negative is clockwise.
   * @param {number}  [options.autoRotateActivationDuration=5000] - Duration before auto rotatation when no user interactivity in ms
   */
  function Viewer(options) {
    THREE.EventDispatcher.call(this);

    let container;

    options = options || {};
    options.controlBar =
      options.controlBar !== undefined ? options.controlBar : true;
    options.controlButtons = options.controlButtons || [
      "fullscreen",
      "setting",
      "video",
    ];
    options.autoHideControlBar =
      options.autoHideControlBar !== undefined
        ? options.autoHideControlBar
        : false;
    options.autoHideInfospot =
      options.autoHideInfospot !== undefined ? options.autoHideInfospot : true;
    options.horizontalView =
      options.horizontalView !== undefined ? options.horizontalView : false;
    options.clickTolerance = options.clickTolerance || 10;
    options.cameraFov = options.cameraFov || 60;
    options.reverseDragging = options.reverseDragging || false;
    options.enableReticle = options.enableReticle || false;
    options.dwellTime = options.dwellTime || 1500;
    options.autoReticleSelect =
      options.autoReticleSelect !== undefined
        ? options.autoReticleSelect
        : true;
    options.viewIndicator =
      options.viewIndicator !== undefined ? options.viewIndicator : true;
    options.indicatorSize = options.indicatorSize || 100;
    options.output = options.output ? options.output : "none";
    options.autoRotate = options.autoRotate || false;
    options.autoRotateSpeed = options.autoRotateSpeed || 2.0;
    options.autoRotateActivationDuration =
      options.autoRotateActivationDuration || 5000;

    this.options = options;

    /*
     * CSS Icon
     * const styleLoader = new StyleLoader();
     * styleLoader.inject( 'icono' );
     */

    // Container
    if (options.container) {
      container = options.container;
      container._width = container.clientWidth;
      container._height = container.clientHeight;
    } else {
      container = document.createElement("div");
      container.classList.add("panolens-container");
      container.style.width = "100%";
      container.style.height = "100%";
      container._width = window.innerWidth;
      container._height = window.innerHeight;
      document.body.appendChild(container);
    }

    this.container = container;

    this.camera =
      options.camera ||
      new THREE.PerspectiveCamera(
        this.options.cameraFov,
        this.container.clientWidth / this.container.clientHeight,
        1,
        10000
      );
    this.scene = options.scene || new THREE.Scene();
    this.renderer =
      options.renderer ||
      new THREE.WebGLRenderer({ alpha: true, antialias: false });
    this.sceneReticle = new THREE.Scene();

    this.viewIndicatorSize = this.options.indicatorSize;

    this.reticle = {};
    this.tempEnableReticle = this.options.enableReticle;

    this.mode = MODES.NORMAL;

    this.OrbitControls;
    this.DeviceOrientationControls;

    this.CardboardEffect;
    this.StereoEffect;

    this.controls;
    this.effect;
    this.panorama;
    this.widget;

    this.hoverObject;
    this.infospot;
    this.pressEntityObject;
    this.pressObject;

    this.raycaster = new THREE.Raycaster();
    this.raycasterPoint = new THREE.Vector2();
    this.userMouse = new THREE.Vector2();
    this.updateCallbacks = [];
    this.requestAnimationId;

    this.cameraFrustum = new THREE.Frustum();
    this.cameraViewProjectionMatrix = new THREE.Matrix4();

    this.autoRotateRequestId;

    this.outputDivElement;

    this.touchSupported =
      "ontouchstart" in window ||
      (window.DocumentTouch && document instanceof DocumentTouch);

    // Handler references
    this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this);
    this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this);
    this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this);
    this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this);
    this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this);
    this.HANDLER_KEY_UP = this.onKeyUp.bind(this);
    this.HANDLER_TAP = this.onTap.bind(this, {
      clientX: this.container.clientWidth / 2,
      clientY: this.container.clientHeight / 2,
    });

    // Flag for infospot output
    this.OUTPUT_INFOSPOT = false;

    // Animations
    this.tweenLeftAnimation = new TWEEN.Tween();
    this.tweenUpAnimation = new TWEEN.Tween();

    // Renderer
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(
      this.container.clientWidth,
      this.container.clientHeight
    );
    this.renderer.setClearColor(0x000000, 0);
    this.renderer.autoClear = false;

    // Append Renderer Element to container
    this.renderer.domElement.classList.add("panolens-canvas");
    this.renderer.domElement.style.display = "block";
    this.container.style.backgroundColor = "#000";
    this.container.appendChild(this.renderer.domElement);

    // Camera Controls
    this.OrbitControls = new OrbitControls(this.camera, this.container);
    this.OrbitControls.id = "orbit";
    this.OrbitControls.minDistance = 1;
    this.OrbitControls.noPan = true;
    this.OrbitControls.autoRotate = this.options.autoRotate;
    this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed;

    this.DeviceOrientationControls = new DeviceOrientationControls(
      this.camera,
      this.container
    );
    this.DeviceOrientationControls.id = "device-orientation";
    this.DeviceOrientationControls.enabled = false;
    this.camera.position.z = 1;

    // Register change event if passiveRenering
    if (this.options.passiveRendering) {
      console.warn("passiveRendering is now deprecated");
    }

    // Controls
    this.controls = [this.OrbitControls, this.DeviceOrientationControls];
    this.control = this.OrbitControls;

    // Cardboard effect
    this.CardboardEffect = new CardboardEffect(this.renderer);
    this.CardboardEffect.setSize(
      this.container.clientWidth,
      this.container.clientHeight
    );

    // Stereo effect
    this.StereoEffect = new StereoEffect(this.renderer);
    this.StereoEffect.setSize(
      this.container.clientWidth,
      this.container.clientHeight
    );

    this.effect = this.CardboardEffect;

    // Add default hidden reticle
    this.addReticle();

    // Lock horizontal view
    if (this.options.horizontalView) {
      this.OrbitControls.minPolarAngle = Math.PI / 2;
      this.OrbitControls.maxPolarAngle = Math.PI / 2;
    }

    // Add Control UI
    if (this.options.controlBar !== false) {
      this.addDefaultControlBar(this.options.controlButtons);
    }

    // Add View Indicator
    if (this.options.viewIndicator) {
      this.addViewIndicator();
    }

    // Reverse dragging direction
    if (this.options.reverseDragging) {
      this.reverseDraggingDirection();
    }

    // Register event if reticle is enabled, otherwise defaults to mouse
    if (this.options.enableReticle) {
      this.enableReticleControl();
    } else {
      this.registerMouseAndTouchEvents();
    }

    // Output infospot position to an overlay container if specified
    if (this.options.output === "overlay") {
      this.addOutputElement();
    }

    // Register dom event listeners
    this.registerEventListeners();

    // Animate
    this.animate.call(this);
  }
  Viewer.prototype = Object.assign(
    Object.create(THREE.EventDispatcher.prototype),
    {
      constructor: Viewer,

      /**
       * Add an object to the scene
       * Automatically hookup with panolens-viewer-handler listener
       * to communicate with viewer method
       * @param {THREE.Object3D} object - The object to be added
       * @memberOf Viewer
       * @instance
       */
      add: function (object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }

          return this;
        }

        this.scene.add(object);

        // All object added to scene has 'panolens-viewer-handler' event to handle viewer communication
        if (object.addEventListener) {
          object.addEventListener(
            "panolens-viewer-handler",
            this.eventHandler.bind(this)
          );
        }

        // All object added to scene being passed with container
        if (object instanceof Panorama && object.dispatchEvent) {
          object.dispatchEvent({
            type: "panolens-container",
            container: this.container,
          });
        }

        if (object instanceof CameraPanorama) {
          object.dispatchEvent({ type: "panolens-scene", scene: this.scene });
        }

        // Hookup default panorama event listeners
        if (object.type === "panorama") {
          this.addPanoramaEventListener(object);

          if (!this.panorama) {
            this.setPanorama(object);
          }
        }
      },

      /**
       * Remove an object from the scene
       * @param  {THREE.Object3D} object - Object to be removed
       * @memberOf Viewer
       * @instance
       */
      remove: function (object) {
        if (object.removeEventListener) {
          object.removeEventListener(
            "panolens-viewer-handler",
            this.eventHandler.bind(this)
          );
        }

        this.scene.remove(object);
      },

      /**
       * Add default control bar
       * @param {array} array - The control buttons array
       * @memberOf Viewer
       * @instance
       */
      addDefaultControlBar: function (array) {
        if (this.widget) {
          console.warn("Default control bar exists");
          return;
        }

        const widget = new Widget(this.container);
        widget.addEventListener(
          "panolens-viewer-handler",
          this.eventHandler.bind(this)
        );
        widget.addControlBar();
        array.forEach((buttonName) => {
          widget.addControlButton(buttonName);
        });

        this.widget = widget;
      },

      /**
       * Set a panorama to be the current one
       * @param {Panorama} pano - Panorama to be set
       * @memberOf Viewer
       * @instance
       */
      setPanorama: function (pano) {
        const leavingPanorama = this.panorama;

        if (pano.type === "panorama" && leavingPanorama !== pano) {
          // Clear exisiting infospot
          this.hideInfospot();

          const afterEnterComplete = function () {
            leavingPanorama && leavingPanorama.onLeave();
            pano.removeEventListener("enter-fade-start", afterEnterComplete);
          };

          pano.addEventListener("enter-fade-start", afterEnterComplete);

          // Assign and enter panorama
          (this.panorama = pano).onEnter();
        }
      },

      /**
       * Event handler to execute commands from child objects
       * @param {object} event - The dispatched event with method as function name and data as an argument
       * @memberOf Viewer
       * @instance
       */
      eventHandler: function (event) {
        if (event.method && this[event.method]) {
          this[event.method](event.data);
        }
      },

      /**
       * Dispatch event to all descendants
       * @param  {object} event - Event to be passed along
       * @memberOf Viewer
       * @instance
       */
      dispatchEventToChildren: function (event) {
        this.scene.traverse(function (object) {
          if (object.dispatchEvent) {
            object.dispatchEvent(event);
          }
        });
      },

      /**
       * Set widget content
       * @method activateWidgetItem
       * @param  {integer} controlIndex - Control index
       * @param  {MODES} mode - Modes for effects
       * @memberOf Viewer
       * @instance
       */
      activateWidgetItem: function (controlIndex, mode) {
        const mainMenu = this.widget.mainMenu;
        const ControlMenuItem = mainMenu.children[0];
        const ModeMenuItem = mainMenu.children[1];

        let item;

        if (controlIndex !== undefined) {
          switch (controlIndex) {
            case 0:
              item = ControlMenuItem.subMenu.children[1];

              break;

            case 1:
              item = ControlMenuItem.subMenu.children[2];

              break;

            default:
              item = ControlMenuItem.subMenu.children[1];

              break;
          }

          ControlMenuItem.subMenu.setActiveItem(item);
          ControlMenuItem.setSelectionTitle(item.textContent);
        }

        if (mode !== undefined) {
          switch (mode) {
            case MODES.CARDBOARD:
              item = ModeMenuItem.subMenu.children[2];

              break;

            case MODES.STEREO:
              item = ModeMenuItem.subMenu.children[3];

              break;

            default:
              item = ModeMenuItem.subMenu.children[1];

              break;
          }

          ModeMenuItem.subMenu.setActiveItem(item);
          ModeMenuItem.setSelectionTitle(item.textContent);
        }
      },

      /**
       * Enable rendering effect
       * @param  {MODES} mode - Modes for effects
       * @memberOf Viewer
       * @instance
       */
      enableEffect: function (mode) {
        if (this.mode === mode) {
          return;
        }
        if (mode === MODES.NORMAL) {
          this.disableEffect();
          return;
        } else {
          this.mode = mode;
        }

        const fov = this.camera.fov;

        switch (mode) {
          case MODES.CARDBOARD:
            this.effect = this.CardboardEffect;
            this.enableReticleControl();

            break;

          case MODES.STEREO:
            this.effect = this.StereoEffect;
            this.enableReticleControl();

            break;

          default:
            this.effect = null;
            this.disableReticleControl();

            break;
        }

        this.activateWidgetItem(undefined, this.mode);

        /**
         * Dual eye effect event
         * @type {object}
         * @event Infospot#panolens-dual-eye-effect
         * @property {MODES} mode - Current display mode
         */
        this.dispatchEventToChildren({
          type: "panolens-dual-eye-effect",
          mode: this.mode,
        });

        // Force effect stereo camera to update by refreshing fov
        this.camera.fov = fov + 10e-3;
        this.effect.setSize(
          this.container.clientWidth,
          this.container.clientHeight
        );
        this.render();
        this.camera.fov = fov;

        /**
         * Dispatch mode change event
         * @type {object}
         * @event Viewer#mode-change
         * @property {MODES} mode - Current display mode
         */
        this.dispatchEvent({ type: "mode-change", mode: this.mode });
      },

      /**
       * Disable additional rendering effect
       * @memberOf Viewer
       * @instance
       */
      disableEffect: function () {
        if (this.mode === MODES.NORMAL) {
          return;
        }

        this.mode = MODES.NORMAL;
        this.disableReticleControl();

        this.activateWidgetItem(undefined, this.mode);

        /**
         * Dual eye effect event
         * @type {object}
         * @event Infospot#panolens-dual-eye-effect
         * @property {MODES} mode - Current display mode
         */
        this.dispatchEventToChildren({
          type: "panolens-dual-eye-effect",
          mode: this.mode,
        });

        this.renderer.setSize(
          this.container.clientWidth,
          this.container.clientHeight
        );
        this.render();

        /**
         * Dispatch mode change event
         * @type {object}
         * @event Viewer#mode-change
         * @property {MODES} mode - Current display mode
         */
        this.dispatchEvent({ type: "mode-change", mode: this.mode });
      },

      /**
       * Enable reticle control
       * @memberOf Viewer
       * @instance
       */
      enableReticleControl: function () {
        if (this.reticle.visible) {
          return;
        }

        this.tempEnableReticle = true;

        // Register reticle event and unregister mouse event
        this.unregisterMouseAndTouchEvents();
        this.reticle.show();
        this.registerReticleEvent();
        this.updateReticleEvent();
      },

      /**
       * Disable reticle control
       * @memberOf Viewer
       * @instance
       */
      disableReticleControl: function () {
        this.tempEnableReticle = false;

        // Register mouse event and unregister reticle event
        if (!this.options.enableReticle) {
          this.reticle.hide();
          this.unregisterReticleEvent();
          this.registerMouseAndTouchEvents();
        } else {
          this.updateReticleEvent();
        }
      },

      /**
       * Enable auto rotation
       * @memberOf Viewer
       * @instance
       */
      enableAutoRate: function () {
        this.options.autoRotate = true;
        this.OrbitControls.autoRotate = true;
      },

      /**
       * Disable auto rotation
       * @memberOf Viewer
       * @instance
       */
      disableAutoRate: function () {
        clearTimeout(this.autoRotateRequestId);
        this.options.autoRotate = false;
        this.OrbitControls.autoRotate = false;
      },

      /**
       * Toggle video play or stop
       * @param {boolean} pause
       * @memberOf Viewer
       * @instance
       * @fires Viewer#video-toggle
       */
      toggleVideoPlay: function (pause) {
        if (this.panorama instanceof VideoPanorama) {
          /**
           * Toggle video event
           * @type {object}
           * @event Viewer#video-toggle
           */
          this.panorama.dispatchEvent({ type: "video-toggle", pause: pause });
        }
      },

      /**
       * Set currentTime in a video
       * @param {number} percentage - Percentage of a video. Range from 0.0 to 1.0
       * @memberOf Viewer
       * @instance
       * @fires Viewer#video-time
       */
      setVideoCurrentTime: function (percentage) {
        if (this.panorama instanceof VideoPanorama) {
          /**
           * Setting video time event
           * @type {object}
           * @event Viewer#video-time
           * @property {number} percentage - Percentage of a video. Range from 0.0 to 1.0
           */
          this.panorama.dispatchEvent({
            type: "video-time",
            percentage: percentage,
          });
        }
      },

      /**
       * This will be called when video updates if an widget is present
       * @param {number} percentage - Percentage of a video. Range from 0.0 to 1.0
       * @memberOf Viewer
       * @instance
       * @fires Viewer#video-update
       */
      onVideoUpdate: function (percentage) {
        /**
         * Video update event
         * @type {object}
         * @event Viewer#video-update
         * @property {number} percentage - Percentage of a video. Range from 0.0 to 1.0
         */
        this.widget &&
          this.widget.dispatchEvent({
            type: "video-update",
            percentage: percentage,
          });
      },

      /**
       * Add update callback to be called every animation frame
       * @param {function} callback
       * @memberOf Viewer
       * @instance
       */
      addUpdateCallback: function (fn) {
        if (fn) {
          this.updateCallbacks.push(fn);
        }
      },

      /**
       * Remove update callback
       * @param  {function} fn - The function to be removed
       * @memberOf Viewer
       * @instance
       */
      removeUpdateCallback: function (fn) {
        const index = this.updateCallbacks.indexOf(fn);

        if (fn && index >= 0) {
          this.updateCallbacks.splice(index, 1);
        }
      },

      /**
       * Show video widget
       * @memberOf Viewer
       * @instance
       */
      showVideoWidget: function () {
        /**
         * Show video widget event
         * @type {object}
         * @event Viewer#video-control-show
         */
        this.widget &&
          this.widget.dispatchEvent({ type: "video-control-show" });
      },

      /**
       * Hide video widget
       * @memberOf Viewer
       * @instance
       */
      hideVideoWidget: function () {
        /**
         * Hide video widget
         * @type {object}
         * @event Viewer#video-control-hide
         */
        this.widget &&
          this.widget.dispatchEvent({ type: "video-control-hide" });
      },

      /**
       * Update video play button
       * @param {boolean} paused
       * @memberOf Viewer
       * @instance
       */
      updateVideoPlayButton: function (paused) {
        if (
          this.widget &&
          this.widget.videoElement &&
          this.widget.videoElement.controlButton
        ) {
          this.widget.videoElement.controlButton.update(paused);
        }
      },

      /**
       * Add default panorama event listeners
       * @param {Panorama} pano - The panorama to be added with event listener
       * @memberOf Viewer
       * @instance
       */
      addPanoramaEventListener: function (pano) {
        // Set camera control on every panorama
        pano.addEventListener(
          "enter-fade-start",
          this.setCameraControl.bind(this)
        );

        // Show and hide widget event only when it's VideoPanorama
        if (pano instanceof VideoPanorama) {
          pano.addEventListener(
            "enter-fade-start",
            this.showVideoWidget.bind(this)
          );
          pano.addEventListener(
            "leave",
            function () {
              if (!(this.panorama instanceof VideoPanorama)) {
                this.hideVideoWidget.call(this);
              }
            }.bind(this)
          );
        }
      },

      /**
       * Set camera control
       * @memberOf Viewer
       * @instance
       */
      setCameraControl: function () {
        this.OrbitControls.target.copy(this.panorama.position);
      },

      /**
       * Get current camera control
       * @return {object} - Current navigation control
       * @memberOf Viewer
       * @instance
       * @returns {THREE.OrbitControls|THREE.DeviceOrientationControls}
       */
      getControl: function () {
        return this.control;
      },

      /**
       * Get scene
       * @memberOf Viewer
       * @instance
       * @return {THREE.Scene} - Current scene which the viewer is built on
       */
      getScene: function () {
        return this.scene;
      },

      /**
       * Get camera
       * @memberOf Viewer
       * @instance
       * @return {THREE.Camera} - The scene camera
       */
      getCamera: function () {
        return this.camera;
      },

      /**
       * Get renderer
       * @memberOf Viewer
       * @instance
       * @return {THREE.WebGLRenderer} - The renderer using webgl
       */
      getRenderer: function () {
        return this.renderer;
      },

      /**
       * Get container
       * @memberOf Viewer
       * @instance
       * @return {HTMLElement} - The container holds rendererd canvas
       */
      getContainer: function () {
        return this.container;
      },

      /**
       * Get control id
       * @memberOf Viewer
       * @instance
       * @return {string} - Control id. 'orbit' or 'device-orientation'
       */
      getControlId: function () {
        return this.control.id;
      },

      /**
       * Get next navigation control id
       * @memberOf Viewer
       * @instance
       * @return {string} - Next control id
       */
      getNextControlName: function () {
        return this.controls[this.getNextControlIndex()].id;
      },

      /**
       * Get next navigation control index
       * @memberOf Viewer
       * @instance
       * @return {number} - Next control index
       */
      getNextControlIndex: function () {
        const controls = this.controls;
        const control = this.control;
        const nextIndex = controls.indexOf(control) + 1;

        return nextIndex >= controls.length ? 0 : nextIndex;
      },

      /**
       * Set field of view of camera
       * @param {number} fov
       * @memberOf Viewer
       * @instance
       */
      setCameraFov: function (fov) {
        this.camera.fov = fov;
        this.camera.updateProjectionMatrix();
      },

      /**
       * Enable control by index
       * @param  {CONTROLS} index - Index of camera control
       * @memberOf Viewer
       * @instance
       */
      enableControl: function (index) {
        index = index >= 0 && index < this.controls.length ? index : 0;

        this.control.enabled = false;

        this.control = this.controls[index];

        this.control.enabled = true;

        switch (index) {
          case CONTROLS.ORBIT:
            this.camera.position.copy(this.panorama.position);
            this.camera.position.z += 1;

            break;

          case CONTROLS.DEVICEORIENTATION:
            this.camera.position.copy(this.panorama.position);

            break;

          default:
            break;
        }

        this.control.update();

        this.activateWidgetItem(index, undefined);
      },

      /**
       * Disable current control
       * @memberOf Viewer
       * @instance
       */
      disableControl: function () {
        this.control.enabled = false;
      },

      /**
       * Toggle next control
       * @memberOf Viewer
       * @instance
       */
      toggleNextControl: function () {
        this.enableControl(this.getNextControlIndex());
      },

      /**
       * Screen Space Projection
       * @memberOf Viewer
       * @instance
       */
      getScreenVector: function (worldVector) {
        const vector = worldVector.clone();
        const widthHalf = this.container.clientWidth / 2;
        const heightHalf = this.container.clientHeight / 2;

        vector.project(this.camera);

        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf;
        vector.z = 0;

        return vector;
      },

      /**
       * Check Sprite in Viewport
       * @memberOf Viewer
       * @instance
       */
      checkSpriteInViewport: function (sprite) {
        this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld);
        this.cameraViewProjectionMatrix.multiplyMatrices(
          this.camera.projectionMatrix,
          this.camera.matrixWorldInverse
        );
        this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix);

        return sprite.visible && this.cameraFrustum.intersectsSprite(sprite);
      },

      /**
       * Reverse dragging direction
       * @memberOf Viewer
       * @instance
       */
      reverseDraggingDirection: function () {
        this.OrbitControls.rotateSpeed *= -1;
        this.OrbitControls.momentumScalingFactor *= -1;
      },

      /**
       * Add reticle
       * @memberOf Viewer
       * @instance
       */
      addReticle: function () {
        this.reticle = new Reticle(0x77ffff, true, this.options.dwellTime);
        this.reticle.hide();
        this.camera.add(this.reticle);
        this.sceneReticle.add(this.camera);
      },

      /**
       * Tween control looking center
       * @param {THREE.Vector3} vector - Vector to be looked at the center
       * @param {number} [duration=1000] - Duration to tween
       * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
       * @memberOf Viewer
       * @instance
       */
      tweenControlCenter: function (vector, duration, easing) {
        if (this.control !== this.OrbitControls) {
          return;
        }

        // Pass in arguments as array
        if (vector instanceof Array) {
          duration = vector[1];
          easing = vector[2];
          vector = vector[0];
        }

        duration = duration !== undefined ? duration : 1000;
        easing = easing || TWEEN.Easing.Exponential.Out;

        var scope, ha, va, chv, cvv, hv, vv, vptc, ov, nv;

        scope = this;

        chv = this.camera.getWorldDirection(new THREE.Vector3());
        cvv = chv.clone();

        vptc = this.panorama
          .getWorldPosition(new THREE.Vector3())
          .sub(this.camera.getWorldPosition(new THREE.Vector3()));

        hv = vector.clone();
        // Scale effect
        hv.x *= -1;
        hv.add(vptc).normalize();
        vv = hv.clone();

        chv.y = 0;
        hv.y = 0;

        ha = Math.atan2(hv.z, hv.x) - Math.atan2(chv.z, chv.x);
        ha = ha > Math.PI ? ha - 2 * Math.PI : ha;
        ha = ha < -Math.PI ? ha + 2 * Math.PI : ha;
        va = Math.abs(
          cvv.angleTo(chv) +
            (cvv.y * vv.y <= 0 ? vv.angleTo(hv) : -vv.angleTo(hv))
        );
        va *= vv.y < cvv.y ? 1 : -1;

        ov = { left: 0, up: 0 };
        nv = { left: 0, up: 0 };

        this.tweenLeftAnimation.stop();
        this.tweenUpAnimation.stop();

        this.tweenLeftAnimation = new TWEEN.Tween(ov)
          .to({ left: ha }, duration)
          .easing(easing)
          .onUpdate(function (ov) {
            scope.control.rotateLeft(ov.left - nv.left);
            nv.left = ov.left;
          })
          .start();

        this.tweenUpAnimation = new TWEEN.Tween(ov)
          .to({ up: va }, duration)
          .easing(easing)
          .onUpdate(function (ov) {
            scope.control.rotateUp(ov.up - nv.up);
            nv.up = ov.up;
          })
          .start();
      },

      /**
       * Tween control looking center by object
       * @param {THREE.Object3D} object - Object to be looked at the center
       * @param {number} [duration=1000] - Duration to tween
       * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
       * @memberOf Viewer
       * @instance
       */
      tweenControlCenterByObject: function (object, duration, easing) {
        let isUnderScalePlaceHolder = false;

        object.traverseAncestors(function (ancestor) {
          if (ancestor.scalePlaceHolder) {
            isUnderScalePlaceHolder = true;
          }
        });

        if (isUnderScalePlaceHolder) {
          var invertXVector = new THREE.Vector3(-1, 1, 1);

          this.tweenControlCenter(
            object
              .getWorldPosition(new THREE.Vector3())
              .multiply(invertXVector),
            duration,
            easing
          );
        } else {
          this.tweenControlCenter(
            object.getWorldPosition(new THREE.Vector3()),
            duration,
            easing
          );
        }
      },

      /**
       * This is called when window size is changed
       * @fires Viewer#window-resize
       * @param {number} [windowWidth] - Specify if custom element has changed width
       * @param {number} [windowHeight] - Specify if custom element has changed height
       * @memberOf Viewer
       * @instance
       */
      onWindowResize: function (windowWidth, windowHeight) {
        let width, height;

        const expand =
          this.container.classList.contains("panolens-container") ||
          this.container.isFullscreen;

        if (windowWidth !== undefined && windowHeight !== undefined) {
          width = windowWidth;
          height = windowHeight;
          this.container._width = windowWidth;
          this.container._height = windowHeight;
        } else {
          const isAndroid = /(android)/i.test(navigator.userAgent);

          const adjustWidth = isAndroid
            ? Math.min(
                document.documentElement.clientWidth,
                window.innerWidth || 0
              )
            : Math.max(
                document.documentElement.clientWidth,
                window.innerWidth || 0
              );

          const adjustHeight = isAndroid
            ? Math.min(
                document.documentElement.clientHeight,
                window.innerHeight || 0
              )
            : Math.max(
                document.documentElement.clientHeight,
                window.innerHeight || 0
              );

          width = expand ? adjustWidth : this.container.clientWidth;
          height = expand ? adjustHeight : this.container.clientHeight;

          this.container._width = width;
          this.container._height = height;
        }

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(width, height);

        // Update reticle
        if (this.options.enableReticle || this.tempEnableReticle) {
          this.updateReticleEvent();
        }

        /**
         * Window resizing event
         * @type {object}
         * @event Viewer#window-resize
         * @property {number} width  - Width of the window
         * @property {number} height - Height of the window
         */
        this.dispatchEvent({
          type: "window-resize",
          width: width,
          height: height,
        });
        this.scene.traverse(function (object) {
          if (object.dispatchEvent) {
            object.dispatchEvent({
              type: "window-resize",
              width: width,
              height: height,
            });
          }
        });
      },

      /**
       * Add output element
       * @memberOf Viewer
       * @instance
       */
      addOutputElement: function () {
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.right = "10px";
        element.style.top = "10px";
        element.style.color = "#fff";
        this.container.appendChild(element);
        this.outputDivElement = element;
      },

      /**
       * Output infospot attach position in developer console by holding down Ctrl button
       * @memberOf Viewer
       * @instance
       */
      outputInfospotPosition: function () {
        const intersects = this.raycaster.intersectObject(this.panorama, true);

        if (intersects.length > 0) {
          const point = intersects[0].point.clone();
          const converter = new THREE.Vector3(-1, 1, 1);
          const world = this.panorama.getWorldPosition(new THREE.Vector3());
          point.sub(world).multiply(converter);

          const message = `${point.x.toFixed(2)}, ${point.y.toFixed(
            2
          )}, ${point.z.toFixed(2)}`;

          if (point.length() === 0) {
            return;
          }

          switch (this.options.output) {
            case "console":
              console.info(message);
              break;

            case "overlay":
              this.outputDivElement.textContent = message;
              break;

            default:
              break;
          }
        }
      },

      /**
       * On mouse down
       * @param {MouseEvent} event
       * @memberOf Viewer
       * @instance
       */
      onMouseDown: function (event) {
        event.preventDefault();

        this.userMouse.x =
          event.clientX >= 0 ? event.clientX : event.touches[0].clientX;
        this.userMouse.y =
          event.clientY >= 0 ? event.clientY : event.touches[0].clientY;
        this.userMouse.type = "mousedown";
        this.onTap(event);
      },

      /**
       * On mouse move
       * @param {MouseEvent} event
       * @memberOf Viewer
       * @instance
       */
      onMouseMove: function (event) {
        event.preventDefault();
        this.userMouse.type = "mousemove";
        this.onTap(event);
      },

      /**
       * On mouse up
       * @param {MouseEvent} event
       * @memberOf Viewer
       * @instance
       */
      onMouseUp: function (event) {
        let onTarget = false;

        this.userMouse.type = "mouseup";

        const type =
          (this.userMouse.x >= event.clientX - this.options.clickTolerance &&
            this.userMouse.x <= event.clientX + this.options.clickTolerance &&
            this.userMouse.y >= event.clientY - this.options.clickTolerance &&
            this.userMouse.y <= event.clientY + this.options.clickTolerance) ||
          (event.changedTouches &&
            this.userMouse.x >=
              event.changedTouches[0].clientX - this.options.clickTolerance &&
            this.userMouse.x <=
              event.changedTouches[0].clientX + this.options.clickTolerance &&
            this.userMouse.y >=
              event.changedTouches[0].clientY - this.options.clickTolerance &&
            this.userMouse.y <=
              event.changedTouches[0].clientY + this.options.clickTolerance)
            ? "click"
            : undefined;

        // Event should happen on canvas
        if (
          event &&
          event.target &&
          !event.target.classList.contains("panolens-canvas")
        ) {
          return;
        }

        event.preventDefault();

        if (event.changedTouches && event.changedTouches.length === 1) {
          onTarget = this.onTap(
            {
              clientX: event.changedTouches[0].clientX,
              clientY: event.changedTouches[0].clientY,
            },
            type
          );
        } else {
          onTarget = this.onTap(event, type);
        }

        this.userMouse.type = "none";

        if (onTarget) {
          return;
        }

        if (type === "click") {
          this.options.autoHideInfospot &&
            this.panorama &&
            this.panorama.toggleInfospotVisibility();
          this.options.autoHideControlBar && this.toggleControlBar();
        }
      },

      /**
       * On tap eveny frame
       * @param {MouseEvent} event
       * @param {string} type
       * @memberOf Viewer
       * @instance
       */
      onTap: function (event, type) {
        const { left, top } = this.container.getBoundingClientRect();
        const { clientWidth, clientHeight } = this.container;

        this.raycasterPoint.x = ((event.clientX - left) / clientWidth) * 2 - 1;
        this.raycasterPoint.y = -((event.clientY - top) / clientHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.raycasterPoint, this.camera);

        // Return if no panorama
        if (!this.panorama) {
          return;
        }

        // output infospot information
        if (
          (event.type !== "mousedown" && this.touchSupported) ||
          this.OUTPUT_INFOSPOT
        ) {
          this.outputInfospotPosition();
        }

        const intersects = this.raycaster.intersectObjects(
          this.panorama.children,
          true
        );
        const intersect_entity = this.getConvertedIntersect(intersects);
        const intersect =
          intersects.length > 0 ? intersects[0].object : undefined;

        if (this.userMouse.type === "mouseup") {
          if (
            intersect_entity &&
            this.pressEntityObject === intersect_entity &&
            this.pressEntityObject.dispatchEvent
          ) {
            this.pressEntityObject.dispatchEvent({
              type: "pressstop-entity",
              mouseEvent: event,
            });
          }

          this.pressEntityObject = undefined;
        }

        if (this.userMouse.type === "mouseup") {
          if (
            intersect &&
            this.pressObject === intersect &&
            this.pressObject.dispatchEvent
          ) {
            this.pressObject.dispatchEvent({
              type: "pressstop",
              mouseEvent: event,
            });
          }

          this.pressObject = undefined;
        }

        if (type === "click") {
          this.panorama.dispatchEvent({
            type: "click",
            intersects: intersects,
            mouseEvent: event,
          });

          if (intersect_entity && intersect_entity.dispatchEvent) {
            intersect_entity.dispatchEvent({
              type: "click-entity",
              mouseEvent: event,
            });
          }

          if (intersect && intersect.dispatchEvent) {
            intersect.dispatchEvent({ type: "click", mouseEvent: event });
          }
        } else {
          this.panorama.dispatchEvent({
            type: "hover",
            intersects: intersects,
            mouseEvent: event,
          });

          if (
            (this.hoverObject &&
              intersects.length > 0 &&
              this.hoverObject !== intersect_entity) ||
            (this.hoverObject && intersects.length === 0)
          ) {
            if (this.hoverObject.dispatchEvent) {
              this.hoverObject.dispatchEvent({
                type: "hoverleave",
                mouseEvent: event,
              });

              this.reticle.stop();
            }

            this.hoverObject = undefined;
          }

          if (intersect_entity && intersects.length > 0) {
            if (this.hoverObject !== intersect_entity) {
              this.hoverObject = intersect_entity;

              if (this.hoverObject.dispatchEvent) {
                this.hoverObject.dispatchEvent({
                  type: "hoverenter",
                  mouseEvent: event,
                });

                // Start reticle timer
                if (
                  (this.options.autoReticleSelect &&
                    this.options.enableReticle) ||
                  this.tempEnableReticle
                ) {
                  this.reticle.start(this.onTap.bind(this, event, "click"));
                }
              }
            }

            if (
              this.userMouse.type === "mousedown" &&
              this.pressEntityObject != intersect_entity
            ) {
              this.pressEntityObject = intersect_entity;

              if (this.pressEntityObject.dispatchEvent) {
                this.pressEntityObject.dispatchEvent({
                  type: "pressstart-entity",
                  mouseEvent: event,
                });
              }
            }

            if (
              this.userMouse.type === "mousedown" &&
              this.pressObject != intersect
            ) {
              this.pressObject = intersect;

              if (this.pressObject.dispatchEvent) {
                this.pressObject.dispatchEvent({
                  type: "pressstart",
                  mouseEvent: event,
                });
              }
            }

            if (
              this.userMouse.type === "mousemove" ||
              this.options.enableReticle
            ) {
              if (intersect && intersect.dispatchEvent) {
                intersect.dispatchEvent({ type: "hover", mouseEvent: event });
              }

              if (
                this.pressEntityObject &&
                this.pressEntityObject.dispatchEvent
              ) {
                this.pressEntityObject.dispatchEvent({
                  type: "pressmove-entity",
                  mouseEvent: event,
                });
              }

              if (this.pressObject && this.pressObject.dispatchEvent) {
                this.pressObject.dispatchEvent({
                  type: "pressmove",
                  mouseEvent: event,
                });
              }
            }
          }

          if (
            !intersect_entity &&
            this.pressEntityObject &&
            this.pressEntityObject.dispatchEvent
          ) {
            this.pressEntityObject.dispatchEvent({
              type: "pressstop-entity",
              mouseEvent: event,
            });

            this.pressEntityObject = undefined;
          }

          if (
            !intersect &&
            this.pressObject &&
            this.pressObject.dispatchEvent
          ) {
            this.pressObject.dispatchEvent({
              type: "pressstop",
              mouseEvent: event,
            });

            this.pressObject = undefined;
          }
        }

        // Infospot handler
        if (intersect && intersect instanceof Infospot) {
          this.infospot = intersect;

          if (type === "click") {
            return true;
          }
        } else if (this.infospot) {
          this.hideInfospot();
        }

        // Auto rotate
        if (this.options.autoRotate && this.userMouse.type !== "mousemove") {
          // Auto-rotate idle timer
          clearTimeout(this.autoRotateRequestId);

          if (this.control === this.OrbitControls) {
            this.OrbitControls.autoRotate = false;
            this.autoRotateRequestId = window.setTimeout(
              this.enableAutoRate.bind(this),
              this.options.autoRotateActivationDuration
            );
          }
        }
      },

      /**
       * Get converted intersect
       * @param {array} intersects
       * @memberOf Viewer
       * @instance
       */
      getConvertedIntersect: function (intersects) {
        let intersect;

        for (var i = 0; i < intersects.length; i++) {
          if (
            intersects[i].distance >= 0 &&
            intersects[i].object &&
            !intersects[i].object.passThrough
          ) {
            if (
              intersects[i].object.entity &&
              intersects[i].object.entity.passThrough
            ) {
              continue;
            } else if (
              intersects[i].object.entity &&
              !intersects[i].object.entity.passThrough
            ) {
              intersect = intersects[i].object.entity;
              break;
            } else {
              intersect = intersects[i].object;
              break;
            }
          }
        }

        return intersect;
      },

      /**
       * Hide infospot
       * @memberOf Viewer
       * @instance
       */
      hideInfospot: function () {
        if (this.infospot) {
          this.infospot.onHoverEnd();

          this.infospot = undefined;
        }
      },

      /**
       * Toggle control bar
       * @memberOf Viewer
       * @instance
       * @fires Viewer#control-bar-toggle
       */
      toggleControlBar: function () {
        /**
         * Toggle control bar event
         * @type {object}
         * @event Viewer#control-bar-toggle
         */
        this.widget &&
          this.widget.dispatchEvent({ type: "control-bar-toggle" });
      },

      /**
       * On key down
       * @param {KeyboardEvent} event
       * @memberOf Viewer
       * @instance
       */
      onKeyDown: function (event) {
        if (
          this.options.output &&
          this.options.output !== "none" &&
          event.key === "Control"
        ) {
          this.OUTPUT_INFOSPOT = true;
        }
      },

      /**
       * On key up
       * @param {KeyboardEvent} event
       * @memberOf Viewer
       * @instance
       */
      onKeyUp: function () {
        this.OUTPUT_INFOSPOT = false;
      },

      /**
       * Update control and callbacks
       * @memberOf Viewer
       * @instance
       */
      update: function () {
        TWEEN.update();

        this.updateCallbacks.forEach(function (callback) {
          callback();
        });

        this.control.update();

        this.scene.traverse(
          function (child) {
            if (
              child instanceof Infospot &&
              child.element &&
              (this.hoverObject === child ||
                child.element.style.display !== "none" ||
                (child.element.left &&
                  child.element.left.style.display !== "none") ||
                (child.element.right &&
                  child.element.right.style.display !== "none"))
            ) {
              if (this.checkSpriteInViewport(child)) {
                const { x, y } = this.getScreenVector(
                  child.getWorldPosition(new THREE.Vector3())
                );
                child.translateElement(x, y);
              } else {
                child.onDismiss();
              }
            }
          }.bind(this)
        );
      },

      /**
       * Rendering function to be called on every animation frame
       * Render reticle last
       * @memberOf Viewer
       * @instance
       */
      render: function () {
        if (this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO) {
          this.renderer.clear();
          this.effect.render(this.scene, this.camera);
          this.effect.render(this.sceneReticle, this.camera);
        } else {
          this.renderer.clear();
          this.renderer.render(this.scene, this.camera);
          this.renderer.clearDepth();
          this.renderer.render(this.sceneReticle, this.camera);
        }
      },

      /**
       * Animate
       * @memberOf Viewer
       * @instance
       */
      animate: function () {
        this.requestAnimationId = requestAnimationFrame(
          this.animate.bind(this)
        );

        this.onChange();
      },

      /**
       * On change
       * @memberOf Viewer
       * @instance
       */
      onChange: function () {
        this.update();
        this.render();
      },

      /**
       * Register mouse and touch event on container
       * @memberOf Viewer
       * @instance
       */
      registerMouseAndTouchEvents: function () {
        const options = { passive: false };

        this.container.addEventListener(
          "mousedown",
          this.HANDLER_MOUSE_DOWN,
          options
        );
        this.container.addEventListener(
          "mousemove",
          this.HANDLER_MOUSE_MOVE,
          options
        );
        this.container.addEventListener(
          "mouseup",
          this.HANDLER_MOUSE_UP,
          options
        );
        this.container.addEventListener(
          "touchstart",
          this.HANDLER_MOUSE_DOWN,
          options
        );
        this.container.addEventListener(
          "touchend",
          this.HANDLER_MOUSE_UP,
          options
        );
      },

      /**
       * Unregister mouse and touch event on container
       * @memberOf Viewer
       * @instance
       */
      unregisterMouseAndTouchEvents: function () {
        this.container.removeEventListener(
          "mousedown",
          this.HANDLER_MOUSE_DOWN,
          false
        );
        this.container.removeEventListener(
          "mousemove",
          this.HANDLER_MOUSE_MOVE,
          false
        );
        this.container.removeEventListener(
          "mouseup",
          this.HANDLER_MOUSE_UP,
          false
        );
        this.container.removeEventListener(
          "touchstart",
          this.HANDLER_MOUSE_DOWN,
          false
        );
        this.container.removeEventListener(
          "touchend",
          this.HANDLER_MOUSE_UP,
          false
        );
      },

      /**
       * Register reticle event
       * @memberOf Viewer
       * @instance
       */
      registerReticleEvent: function () {
        this.addUpdateCallback(this.HANDLER_TAP);
      },

      /**
       * Unregister reticle event
       * @memberOf Viewer
       * @instance
       */
      unregisterReticleEvent: function () {
        this.removeUpdateCallback(this.HANDLER_TAP);
      },

      /**
       * Update reticle event
       * @memberOf Viewer
       * @instance
       */
      updateReticleEvent: function () {
        const clientX =
          this.container.clientWidth / 2 + this.container.offsetLeft;
        const clientY = this.container.clientHeight / 2;

        this.removeUpdateCallback(this.HANDLER_TAP);
        this.HANDLER_TAP = this.onTap.bind(this, { clientX, clientY });
        this.addUpdateCallback(this.HANDLER_TAP);
      },

      /**
       * Register container and window listeners
       * @memberOf Viewer
       * @instance
       */
      registerEventListeners: function () {
        // Resize Event
        window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, true);

        // Keyboard Event
        window.addEventListener("keydown", this.HANDLER_KEY_DOWN, true);
        window.addEventListener("keyup", this.HANDLER_KEY_UP, true);
      },

      /**
       * Unregister container and window listeners
       * @memberOf Viewer
       * @instance
       */
      unregisterEventListeners: function () {
        // Resize Event
        window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, true);

        // Keyboard Event
        window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, true);
        window.removeEventListener("keyup", this.HANDLER_KEY_UP, true);
      },

      /**
       * Dispose all scene objects and clear cache
       * @memberOf Viewer
       * @instance
       */
      dispose: function () {
        // Unregister dom event listeners
        this.unregisterEventListeners();

        // recursive disposal on 3d objects
        function recursiveDispose(object) {
          for (var i = object.children.length - 1; i >= 0; i--) {
            recursiveDispose(object.children[i]);
            object.remove(object.children[i]);
          }

          if (object instanceof Infospot) {
            object.dispose();
          }

          object.geometry && object.geometry.dispose();
          object.material && object.material.dispose();
        }

        recursiveDispose(this.scene);

        // dispose widget
        if (this.widget) {
          this.widget.dispose();
          this.widget = null;
        }

        // clear cache
        if (Cache && Cache.enabled) {
          Cache.clear();
        }
      },

      /**
       * Destory viewer by disposing and stopping requestAnimationFrame
       * @memberOf Viewer
       * @instance
       */
      destory: function () {
        this.dispose();
        this.render();
        cancelAnimationFrame(this.requestAnimationId);
      },

      /**
       * On panorama dispose
       * @memberOf Viewer
       * @instance
       */
      onPanoramaDispose: function (panorama) {
        if (panorama instanceof VideoPanorama) {
          this.hideVideoWidget();
        }

        if (panorama === this.panorama) {
          this.panorama = null;
        }
      },

      /**
       * Load ajax call
       * @param {string} url - URL to be requested
       * @param {function} [callback] - Callback after request completes
       * @memberOf Viewer
       * @instance
       */
      loadAsyncRequest: function (url, callback) {
        const request = new XMLHttpRequest();
        request.onloadend = function (event) {
          callback && callback(event);
        };
        request.open("GET", url, true);
        request.send(null);
      },

      /**
       * View indicator in upper left
       * @memberOf Viewer
       * @instance
       */
      addViewIndicator: function () {
        const scope = this;

        function loadViewIndicator(asyncEvent) {
          if (asyncEvent.loaded === 0) return;

          const viewIndicatorDiv =
            asyncEvent.target.responseXML.documentElement;
          viewIndicatorDiv.style.width = scope.viewIndicatorSize + "px";
          viewIndicatorDiv.style.height = scope.viewIndicatorSize + "px";
          viewIndicatorDiv.style.position = "absolute";
          viewIndicatorDiv.style.top = "10px";
          viewIndicatorDiv.style.left = "10px";
          viewIndicatorDiv.style.opacity = "0.5";
          viewIndicatorDiv.style.cursor = "pointer";
          viewIndicatorDiv.id = "panolens-view-indicator-container";

          scope.container.appendChild(viewIndicatorDiv);

          const indicator = viewIndicatorDiv.querySelector("#indicator");
          const setIndicatorD = function () {
            scope.radius = scope.viewIndicatorSize * 0.225;
            scope.currentPanoAngle =
              scope.camera.rotation.y - THREE.Math.degToRad(90);
            scope.fovAngle = THREE.Math.degToRad(scope.camera.fov);
            scope.leftAngle = -scope.currentPanoAngle - scope.fovAngle / 2;
            scope.rightAngle = -scope.currentPanoAngle + scope.fovAngle / 2;
            scope.leftX = scope.radius * Math.cos(scope.leftAngle);
            scope.leftY = scope.radius * Math.sin(scope.leftAngle);
            scope.rightX = scope.radius * Math.cos(scope.rightAngle);
            scope.rightY = scope.radius * Math.sin(scope.rightAngle);
            scope.indicatorD =
              "M " +
              scope.leftX +
              " " +
              scope.leftY +
              " A " +
              scope.radius +
              " " +
              scope.radius +
              " 0 0 1 " +
              scope.rightX +
              " " +
              scope.rightY;

            if (
              scope.leftX &&
              scope.leftY &&
              scope.rightX &&
              scope.rightY &&
              scope.radius
            ) {
              indicator.setAttribute("d", scope.indicatorD);
            }
          };

          scope.addUpdateCallback(setIndicatorD);

          const indicatorOnMouseEnter = function () {
            this.style.opacity = "1";
          };

          const indicatorOnMouseLeave = function () {
            this.style.opacity = "0.5";
          };

          viewIndicatorDiv.addEventListener(
            "mouseenter",
            indicatorOnMouseEnter
          );
          viewIndicatorDiv.addEventListener(
            "mouseleave",
            indicatorOnMouseLeave
          );
        }

        this.loadAsyncRequest(DataImage.ViewIndicator, loadViewIndicator);
      },

      /**
       * Append custom control item to existing control bar
       * @param {object} [option={}] - Style object to overwirte default element style. It takes 'style', 'onTap' and 'group' properties.
       * @memberOf Viewer
       * @instance
       */
      appendControlItem: function (option) {
        const item = this.widget.createCustomItem(option);

        if (option.group === "video") {
          this.widget.videoElement.appendChild(item);
        } else {
          this.widget.barElement.appendChild(item);
        }

        return item;
      },

      /**
       * Clear all cached files
       * @memberOf Viewer
       * @instance
       */
      clearAllCache: function () {
        Cache.clear();
      },

      /*
			Author: silqwer,
			Compass event handler
		*/

      onRotationChange: function (element) {
        var camera = this.camera;

        this.control.addEventListener(
          "change",
          function () {
            var rotationY = camera.rotation.y;
            var dy = 0;

            if (rotationY < 0) {
              dy = THREE.Math.radToDeg(rotationY + 2 * Math.PI);
            } else {
              dy = THREE.Math.radToDeg(rotationY);
            }

            element.style.transform = "rotate(" + (dy % 360) + "deg)";
          },
          false
        );
      },
    }
  );

  /**
   * Panolens.js
   * @author pchen66
   * @namespace PANOLENS
   */
  window.TWEEN = Tween;

  exports.BasicPanorama = BasicPanorama;
  exports.CONTROLS = CONTROLS;
  exports.CameraPanorama = CameraPanorama;
  exports.CubePanorama = CubePanorama;
  exports.CubeTextureLoader = CubeTextureLoader;
  exports.DataImage = DataImage;
  exports.EmptyPanorama = EmptyPanorama;
  exports.GoogleStreetviewPanorama = GoogleStreetviewPanorama;
  exports.ImageLittlePlanet = ImageLittlePlanet;
  exports.ImageLoader = ImageLoader;
  exports.ImagePanorama = ImagePanorama;
  exports.Infospot = Infospot;
  exports.LittlePlanet = LittlePlanet;
  exports.MODES = MODES;
  exports.Media = Media;
  exports.Panorama = Panorama;
  exports.REVISION = REVISION;
  exports.Reticle = Reticle;
  exports.TextureLoader = TextureLoader;
  exports.VideoPanorama = VideoPanorama;
  exports.Viewer = Viewer;
  exports.Widget = Widget;

  Object.defineProperty(exports, "__esModule", { value: true });
});
